---
description: Декларативный язык запросов cypher
title: Cypher query language
tags: bd graphs
---
Cypher — это язык графовых запросов [[neo4j]], который позволяет извлекать данные из графа. Это похоже на SQL для графов, и он был вдохновлен SQL, поэтому он позволяет вам сосредоточиться на том, какие данные вы хотите получить из графа (а не на том, как их получить). Это самый простой язык графов для изучения из-за его сходства с другими языками и интуитивности.

![cypher example](../attachments/2022-08-01-16-08-43.png)

Поскольку Cypher предназначен для чтения человеком, его конструкция основан на английской лексике, чтобы сделать синтаксис наглядным и понятным.

![cypher example](../attachments/2022-08-03-14-14-38.png)

Узлы в cypher могут быть анонимными (результат будет отброшен в конце вычисленийц) или поименованными меткой. Результат можно присваивать переменной.

```sql
()                  //anonymous node (no label or variable)
                    //can refer to any node in the database
(p:Person)          //using variable p and label Person
(:Technology)       //no variable, label Technology
(work:Company)      //using variable work and label Company
```

Отношения представлены в Cypher с помощью стрелки --> или <-- между двумя узлами. Ненаправленные отношения представлены без стрелки и только с двумя тире --. Это означает, что связь может быть пройдена в любом направлении. Хотя направление должно быть указано для связи в бд, его можно сопоставить с ненаправленным отношением, когда Cypher игнорирует любое конкретное направление и извлекает отношение и подключенные узлы, независимо от физического направления. Это позволяет запросам быть гибкими и не заставлять пользователя знать физическое направление отношений, хранящихся в базе данных.

Если данные хранятся с одним направлением связи, а в запросе указано неправильное направление, Cypher не вернет никаких результатов. В тех случаях, когда вы не уверены в направлении, лучше использовать ненаправленную связь и получить некоторые результаты.

```sql
//data stored with this direction
CREATE (p:Person)-[:LIKES]->(t:Technology)

//query relationship backwards will not return results
MATCH (p:Person)<-[:LIKES]-(t:Technology)

//better to query with undirected relationship unless sure of direction
MATCH (p:Person)-[:LIKES]-(t:Technology)
```

Типы отношений классифицируют отношения и придают им значение, аналогично тому, как метки группируют узлы. Обычно вы можете идентифицировать отношения в своей модели данных, найдя действия или глаголы. Вы можете указать любой тип отношений между узлами, который вы хотите, но мы рекомендуем использовать хорошие соглашения об именах, используя глаголы и действия. Плохие имена типов отношений затрудняют чтение и запись Cypher (помните, это должно звучать как английский!).

![cypher relations](../attachments/2022-08-03-14-20-26.png)

Как и в случае с узлами, если мы хотим позже обратиться к связи в запросе, мы можем указать для нее переменную типа `[r]`или `[rel]`. Мы также можем использовать более длинные и выразительные имена переменных, такие как `[likes]` или `[knows]`. Если вам не нужно ссылаться на связь позже, вы можете указать анонимную связь с помощью двух дефисов `--`, `-->`, `<--`.

Например, вы можете использовать или `-[rel]->` или `-[rel:LIKES]->` и вызвать `rel` переменную позже в своем запросе, чтобы сослаться на связь и ее детали.

Если вы забудете поставить двоеточие перед таким типом отношения `-[LIKES]->`, оно представляет собой переменную (а не тип отношения). Поскольку тип отношений не объявлен, Cypher будет искать все типы отношений.

Свойства в cypher представляют собой пары «имя-значение», которые предоставляют дополнительную информацию для наших узлов и отношений. Чтобы представить их в Cypher, мы можем использовать фигурные скобки внутри круглых скобок узла или скобок отношения. Затем имя и значение свойства заключаются в фигурные скобки: `-[rel:IS_FRIENDS_WITH {since: 2018}]->`

![cypher properties](../attachments/2022-08-03-14-26-22.png)

[Доступные типы данных свойств](https://neo4j.com/docs/cypher-manual/current/syntax/values/)

Основой всех запросов в cypher являются паттерны. Пример:

```sql
(p:Person {name: "Jennifer"})-[rel:LIKES]->(g:Technology {type: "Graphs"})
```

## [cypher keywords](https://neo4j.com/developer/cypher/querying/)

Как и в большинстве языков программирования, в Cypher есть несколько слов, зарезервированных для определенных действий в частях запроса. Нам нужна возможность создавать, читать, обновлять или удалять данные в Neo4j, и ключевые слова помогают нам выполнять эту функцию.

**MATCH**. Ключевое слово MATCH в Cypher — это то, что ищет существующий узел, отношение, метку, свойство или шаблон в базе данных. Если вы знакомы с SQL, MATCH работает почти так же, как SELECT в SQL.

Вы можете найти все метки узлов в базе данных, выполнить поиск определенного узла, найти все узлы с определенной взаимосвязью, найти закономерности узлов и взаимосвязей и многое другое с помощью MATCH.

**RETURN**. Ключевое слово RETURN в Cypher указывает, какие значения или результаты вы хотите вернуть из запроса Cypher. Вы можете указать Cypher возвращать узлы, отношения, свойства узлов и отношений или шаблоны в результатах вашего запроса. RETURN не требуется при выполнении процедур записи, но необходим для чтения.

Переменные узла и отношения, которые мы обсуждали ранее, становятся важными при использовании RETURN. Чтобы вернуть узлы, отношения, свойства или шаблоны, вам необходимо указать переменные в вашем MATCH предложении для данных, которые вы хотите вернуть.

Все узлы с меткой Person

```sql
MATCH (p:Person)
RETURN p
LIMIT 1
```

С определенным значением свойства на узле (имя режисера)

```sql
MATCH (tom:Person {name: 'Tom Hanks'})
RETURN tom
```

Фильмы данного режиссера

```sql
MATCH (:Person {name: 'Tom Hanks'})-[:DIRECTED]->(movie:Movie)
RETURN movie
```

Как и в случае с SQL, вы можете переименовать возвращаемые результаты, используя AS и псевдоним свойства с более понятным именем.

```sql
//cleaner printed results with aliasing
MATCH (tom:Person {name:'Tom Hanks'})-[rel:DIRECTED]-(movie:Movie)
RETURN tom.name
AS name, tom.born
AS `Year Born`, movie.title
AS title, movie.released
AS `Year Released`
```

### [Create, Update, and Delete Operations](https://neo4j.com/developer/cypher/updating/)

CRUD в графе работаtт немного иначе, чем в других типах баз данных.

Добавление данных в Cypher работает очень похоже на оператор вставки любого другого языка доступа к данным. Однако вместо INSERT, как в SQL, Cypher использует CREATE. Вы можете использовать CREATE для вставки узлов, отношений и шаблонов в Neo4j.

```sql
CREATE (friend:Person {name: 'Mark'})
RETURN friend

MATCH (jennifer:Person {name: 'Jennifer'})
MATCH (mark:Person {name: 'Mark'})
CREATE (jennifer)-[rel:IS_FRIENDS_WITH]->(mark)
```

Обратите внимание, что мы запускаем два MATCH запроса, прежде чем создать связь между узлами. Почему это? Причина, по которой мы сначала выполняем сопоставление для узла Дженнифер и сопоставления для узла Марка, заключается в том, что CREATE ключевое слово выполняет слепую вставку и создает весь шаблон, независимо от того, существует ли он уже в базе данных. Это означает, что при выполнении приведенного ниже оператора Cypher будут вставлены дубликаты узлов Jennifer и Mark. Чтобы этого избежать, наш предыдущий запрос сначала нашел существующие узлы, а затем создал между ними новую связь.

```sql
//this query will create duplicate nodes for Mark and Jennifer
CREATE (j:Person {name: 'Jennifer'})-[rel:IS_FRIENDS_WITH]->(m:Person {name: 'Mark'})
```

Возможно, у вас уже есть узел или связь в данных, но вы хотите изменить их свойства. Это можно сделать, сопоставив шаблон, который вы хотите найти, и используя SET для добавления, удаления или обновления свойств.

```sql
MATCH (p:Person {name: 'Jennifer'})
SET p.birthdate = date('1980-01-01')
RETURN p
```

Если бы мы теперь хотели изменить ее день рождения, мы могли бы использовать тот же запрос выше, чтобы снова найти узел Дженнифер и указать другую дату в SET.

Мы также можем обновить информацию об WORKS_FOR отношениях Дженнифер с ее компанией, указав год, когда она начала там работать. Для этого вы можете использовать синтаксис, аналогичный приведенному выше, для обновления узлов.

```sql
MATCH (:Person {name: 'Jennifer'})-[rel:WORKS_FOR]-(:Company {name: 'Neo4j'})
SET rel.startYear = date({year: 2018})
RETURN rel
```

Еще одна операция, которую мы рассмотрим, — это удаление данных в Cypher. Для этой операции Cypher использует DELETE - ключевое слово для удаления узлов и связей. Это очень похоже на удаление данных в других языках, таких как SQL, за одним исключением. Поскольку Neo4j совместим с ACID, вы не можете удалить узел, если он все еще имеет связи. Если бы вы могли это сделать, вы могли бы получить связь, не указывающую на узел, и неполный граф. Мы рассмотрим, как удалить отключенный узел, связь, а также узел, у которого все еще есть связи.

Чтобы удалить связь, нужно найти начальный и конечный узлы для связи, которое вы хотите удалить, а затем использовать DELETE.

```sql
MATCH (j:Person {name: 'Jennifer'})-[r:IS_FRIENDS_WITH]->(m:Person {name: 'Mark'})
DELETE r
```

Чтобы удалить узел, который не имеет никаких связей, нужно найти узел, который вы хотите удалить, а затем использовать DELETE.

```sql
MATCH (m:Person {name: 'Mark'})
DELETE m
```

Вместо выполнения двух последних запросов для удаления IS_FRIENDS_WITH маязи и Person узла для Марка мы можем выполнить один оператор для одновременного удаления узла и связи. Как мы упоминали выше, Neo4j совместим с ACID, поэтому он не позволяет нам удалять узел, если он все еще имеет связи. Использование DETACH DELETE синтаксиса говорит Cypher удалить любые связи, которые есть у узла, а также удалить сам узел.

```sql
MATCH (m:Person {name: 'Mark'})
DETACH DELETE m
```

Вы также можете удалить свойства, но вместо использования DELETE мы можем использовать несколько других подходов. Первый вариант заключается в использовании REMOVE. Это сообщает Neo4j, что вы хотите полностью удалить свойство из узла и больше не хранить его.

Второй вариант — использовать SET, чтобы установить значение свойства в null. В отличие от других моделей баз данных, Neo4j не хранит нулевые значения. Вместо этого он хранит только те свойства и значения, которые имеют смысл для ваших данных. Это означает, что у вас могут быть разные типы и количество свойств на различных узлах и отношениях в вашем графе.

```sql
//delete property using REMOVE keyword
MATCH (n:Person {name: 'Jennifer'})
REMOVE n.birthdate

//delete property with SET to null value
MATCH (n:Person {name: 'Jennifer'})
SET n.birthdate = null
```

Смотир еще:

- [документация для neo4j](https://neo4j.com/developer/cypher/)
- [openCypher](http://opencypher.org/)
- [[graphs]]
- [[neo4j]]
- [[python-api-neo4j]]

[//begin]: # "Autogenerated link references for markdown compatibility"
[neo4j]: neo4j "Neo4j graph data base"
[graphs]: ../lists/graphs "Machine learning with graphs"
[python-api-neo4j]: python-api-neo4j "Python api for neo4j"
[//end]: # "Autogenerated link references"