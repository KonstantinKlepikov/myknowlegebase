---
description: Github action - как запускать экшены последовательно
tags: cl
---
# How start second github action after success first

## Тот же workflow, отдельный job с needs ключом

В одном воркфлоу можно определить дополнительный job через need - в этом случае экшен будет выполнен, только если успешно выполнен экшен в need

```yml
name: CI build and notify

on: [push]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2
    
    - name: Deploy Docker image to Google Cloud Run
      run: ...

  notify:
    needs: build
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v2

      - name: Notify Slack and send eMail
        run: ...
```

## Отдельный workflow, использующий workflow_run эвент в качестве триггера

Можно разделить события на два воркфлоу и запускать второй только, если успешен первый.

```yml
# build.yml
name: CI build

on: [push]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2

    - name: Deploy Docker image to Google Cloud Run
      run: ...
```

```yml
# notify.yml
name: CI notify

# Only trigger, when the build workflow succeeded
on:
  workflow_run:
    workflows: ["CI build"]
    types:
      - completed

jobs:
  notify:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v2

      - name: Notify Slack and send eMail
        run: ...
```

Важным недостатком второго подхода является то, что оба экшена должны быть реализованы в ветке по умолчанию длят ого, чтобы второй исполнился. Плюс, очевидно, заключается в том, что можно отключить второй экшен из админки github, не влезая в код.

[Ссылка на оверфло](https://stackoverflow.com/a/65698892/15966204)

- [[github-action]]
- [[cl]]

[//begin]: # "Autogenerated link references for markdown compatibility"
[github-action]: github-action "Githunb action"
[cl]: ../lists/cl "Ci - непрервыная интеграция"
[//end]: # "Autogenerated link references"