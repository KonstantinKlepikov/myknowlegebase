---
description: Некоторые сложные термины и понятия в python
tags: python-standart-library
---
# Python glossary

В этой заметке небольшая подборка терминов, которые мне кажутся сложными и которые легче запомнить, описав своими словами со ссылками на источники.

## abstract base class

Абстрактные базовые классы дополняют утиную типизацию, предоставляя способ определения интерфейсов, когда другие методы, такие как `hasattr()`, были бы негромоздкими. ABC вводят виртуальные подклассы, которые не наследуются от класса, но по-прежнему распознаются `isinstance()` и `issubclass()`. Python имеет множество встроенных ABC, от которых можно отнаследоваться:

- структуры данных в модуле `collection.abc`
- числа в `numeric`
- потоки в модуле `io` см. [[python-filesystem]]
- средства поиска и загрузчиков импорта `importlib.abc`
- ряд модулей реализуют свои собственные абстрактные классы для ряда задач, к примеру [[asyncio]] и [[threading]]

Можно создавать свои собственные абстрактные классы с помощью модуля `abc`

Смотри подробнее [[abc]]

## bytecode

Исходный код Python компилируется в байт-код, внутреннее представление программы Python в интерпретаторе CPython. Байт-код также кэшируется в файлах `.pyc`, поэтому второй раз выполнение того же файла происходит быстрее (можно избежать перекомпиляции из исходного кода в байт-код). Виртуальная машина python выполняет машинный код, соответствующий байт-коду. Не ожидается, что байт-коды будут работать между разными виртуальными машинами Python или будут стабильными между выпусками Python. Список инструкций по байт-коду можно найти в документации к модулю [dis](https://docs.python.org/3/library/dis.html#python-bytecode-instructions).

## callback

Функция-подпрограмма, которая передается другой функции в качестве аргумента для выполнения в будущем. Довольно часто используется, к примеру, в [[asyncio]]

## context variable

Переменная, которая может иметь разные значения в зависимости от контекста. Это похоже на локальное хранилище потока, в котором каждый поток выполнения может иметь разные значения переменной. Однако с переменными контекста может быть несколько контекстов в одном потоке выполнения, и основное использование переменных контекста - отслеживать переменные в параллельных асинхронных задачах. [Contextvars](https://docs.python.org/3/library/contextvars.html#module-contextvars). [[contextvars]]

## descriptor

Любой объект, который определяет методы `__get__()`, `__set__()` или `__delete__()`. Когда атрибут класса является дескриптором, его особое поведение привязки запускается при поиске атрибута. Обычно при использовании a.b для получения, установки или удаления атрибута выполняется поиск объекта с именем b в словаре классов для a, но если b является дескриптором, вызывается соответствующий метод дескриптора. Подробнее читай тут [[python-descriptors]]

## dictionary

Ассоциативный массив, мапящий ключи на значения. Ключами могут быть только объекты, реализующие `__hash__()` и `__eq__()` методы (так называемые, "хешируемые объекты"). Словарным представлением (dictionary view) являются объекты, возвращаемые методами `dict.keys()`, `dict.values()`, `and dict.items()`. Они обеспечивают динамическое представление словарей, что означает, что когда словарь изменяется, представление отражает эти изменения.

## duck-typing

Стиль программирования, который не смотрит на тип объекта, чтобы определить, имеет ли он правильный интерфейс; вместо этого метод или атрибут просто вызывается или используется. За счет акцентирования внимания на интерфейсах, а не на конкретных типах, хорошо разработанный код повышает его гибкость за счет реализации полиморфизма. Утиная типизация позволяет отказаться от тестов с использованием `type()` или `isinstance()`. Вместо этого обычно используются тесты `hasattr()` или программирование EAFP.

EAFP(Easier to ask for forgiveness than permission - проще извиниться, чем получить разрешение) - этот общий стиль программирования Python предполагает наличие существующих валидных ключей или атрибутов и перехватывает исключения, если предположение оказывается ложным. Противоположность - LBYL (Look before you leap - посмотри, прежде чем прышать), стиль программирования в котомром явно проверяют предварительные условия перед вызовом или поиском. Характеризуется наличием множества операторов if. В многопоточной среде подход LBYL может привести к возникновению состояния гонки

## file object (или file-like object)

Объект, предоставляющий файловый API (с такими методами, как `read()` или `write()`) для лежащего в основе АПИ ресурса. В зависимости от способа создания файловый объект может опосредовать доступ к реальному файлу на диске или к другому типу запоминающего устройства или устройства связи (например, стандартный ввод). В python три категории файловых объектов - raw binary files, buffered binary files и text files.

## generator и generator iterator

Генератор - это функция, которая возвращает generator iterator (итератор генератора). Это похоже на обычную функцию, за исключением того, что она содержит выражения `yield` для создания серии значений, которые можно использовать в цикле for или которые можно получить по одному с помощью функции `next()`.

В итераторе генератора Каждый `yield` временно приостанавливает обработку, запоминая состояние на момент выхода (включая локальные переменные и ожидающие состояния). Когда итератор генератора возобновляет работу, он продолжает работу с того места, где остановился (в отличие от функций, которые запускаются заново при каждом вызове).

Смотри подробнее в [[python-datamodel]]

## generic function и generic type

Дженерик функция - Функция, состоящая из нескольких функций, реализующих одну и ту же операцию для разных типов. Какую реализацию следует использовать во время вызова, определяется алгоритмом диспетчеризации.

single dispatch - форма диспетчеризации универсальной функции, в которой реализация выбирается на основе типа одинственного аргумента

Дженерик тип - тип, который можно параметризовать; обычно это контейнерный класс, такой как list или dict. Используется в основном для подсказок типа и аннотаций.

Смотри [[type-annotation]]

## import path

Список местоположений (или записей путей), который просматривается для поиска модули для импорта. Во время импорта этот список обычно берется из `sys.path`, но для подпакетов он также может поступать из атрибута `__path__` родительского пакета.

## interpreted

Python - это интерпретируемый язык, в отличие от скомпилированного, хотя различие может быть нечетким из-за наличия компилятора байт-кода. Это означает, что исходные файлы можно запускать напрямую, без явного создания исполняемого файла.

Интерпретатор python запускаемый и останавливаемый. Когда интерпретатор останавливают, он входит в особую фазу, на которой он постепенно высвобождает все выделенные ресурсы, такие как модули и различные важные внутренние структуры. Он также делает несколько обращений к сборщику мусора. Это может вызвать выполнение кода в определяемых пользователем деструкторах или обратных вызовах. Код, выполняемый на этапе завершения работы, может столкнуться с различными исключениями, поскольку ресурсы, на которые он опирается, могут больше не работать.

## iterable и iterator

**iterable (итерируемый объект)** - это объект, способный возвращать свои вхождения по одному. Примеры iterable включают все типы последовательностей (такие как `list`, `str` и `tuple`) и некоторые типы, не являющиеся последовательностями, такие как `dict`, файловые объекты и объекты любых классов, в которх определены методы `__iter__()` или методы `__getitem__()`. Итерируемые объекты можно использовать в цикле `for` и во многих других местах, где требуется последовательность (`zip()`, `map()`,…). Когда итерируемый объект передается в качестве аргумента встроенной функции `iter()`, она возвращает итератор для объекта. Этот итератор подходит для одного прохода по набору значений. При использовании итерируемых объектов обычно нет необходимости вызывать `iter()`. Оператор `for` делает это автоматически, создавая временную безымянную переменную для хранения итератора на время цикла.

**Итератор** - объект, представляющий поток данных. Повторные вызовы метода `__next__()` итератора (или передача его встроенной функции `next()`) возвращают последовательные элементы в потоке. Когда больше нет доступных данных итератора, возбуждается исключение `StopIteration`. На этом этапе объект итератора исчерпан, и любые дальнейшие вызовы метода `__next__()` просто снова вызывают `StopIteration`. Итераторы должны реализовывать метод `__iter__()`, который возвращает сам объект итератора, поэтому каждый итератор также является итеративным и может использоваться в большинстве мест, где принимаются другие итераторы.

Объект-контейнер (например, список) создает новый итератор каждый раз, когда вы передаете его функции `iter()` или используете в цикле `for`. Попытка сделать это с помощью итератора просто вернет тот же исчерпанный объект итератора, который использовался в предыдущем проходе итерации, делая его похожим на пустой контейнер. [Подробнее тут](https://docs.python.org/3/library/stdtypes.html#typeiter).

```python
>>> p = 'abcdefg'.__iter__()
>>> print(p)
<str_iterator object at 0x7fe4db12c4c0>

>>> for i in p:
...     print(i)
a
b
c
d
e
f
g

>>> print(next(p))
Traceback (most recent call last):
  File "<string>", line 7, in <module>
StopIteration
```

Python поддерживает концепцию итерации по контейнерам. Это реализуется с использованием двух различных методов.

Для объектов-контейнеров необходимо определить один метод, чтобы обеспечить итеративную поддержку:

`container.__iter__()` возвращает объект итератора. Если контейнер поддерживает различные типы итераций, могут быть предоставлены дополнительные методы для специального запроса итераторов для этих типов итераций. (Примером объект, поддерживающий несколько форм итерации, может иметь древовидную структуру, поддерживающий как обход в ширину, так и обход в глубину)

Сами объекты итератора должны поддерживать следующие два метода, которые вместе образуют протокол итератора:

`iterator.__iter__()` Возвращает сам объект итератора. Это необходимо, чтобы позволить использовать как контейнеры, так и итераторы с операторами `for` и `in`

`iterator.__next__()` Возвращает следующий элемент из итератора. Если других элементов нет, должно быть вызвано исключение `StopIteration`

Python определяет несколько объектов итераторов для поддержки итерации по общим и конкретным типам последовательностей, словарям и другим более специализированным формам. Конкретные типы не важны, кроме их реализации протокола итератора.

Как только метод `__next__()` итератора вызывает StopIteration, он должен продолжать это делать при последующих вызовах. Реализации, которые не подчиняются этому свойству, считаются недопустимыми.

[Подробнее тут](https://docs.python.org/3/library/stdtypes.html#iterator-types). Смотри так-же [[python-datamodel]].

## key function

Ключевая функция или функция сопоставления - это вызываемый объект, который возвращает значение, используемое для сортировки или упорядочивания. Например, `locale.strxfrm()` используется для создания ключа сортировки, который учитывает соглашения о сортировке для конкретной локали. Ряд инструментов в Python принимают ключевые функции для управления порядком или группировкой элементов. Это `min()`, `max()`, `sorted()`, `list.sort()`, `heapq.merge()`, `heapq.nsmallest()`, `heapq.nlargest()` и `itertools.groupby()`. Есть несколько способов создать ключевую функцию. Например. метод `str.lower()` может служить ключевой функцией для сортировки без учета регистра. В качестве альтернативы, ключевая функция может быть построена из лямбда-выражения. Кроме того, модуль `operator` предоставляет три основных конструктора функций: `attrgetter()`, `itemgetter()` и `methodcaller()`. См. Sorting HOW TO для примеров того, как создавать и использовать ключевые функции.

Смотри [[python-sorting]]

## metaclass

Класс класса. Определение класса создает имя класса, словарь класса и список базовых классов. Метакласс отвечает за получение этих трех аргументов и создание класса. Большинство объектно-ориентированных языков программирования предоставляют реализацию по умолчанию. Особенность Python заключается в том, что можно создавать собственные метаклассы. Они использовались для регистрации доступа к атрибутам, добавления безопасности потоков, создания объектов слежения, реализации синглтонов и многих других задач.

## named tuple

Термин «именованный кортеж» применяется к любому типу или классу, который наследуется от кортежа и чьи индексируемые элементы также доступны с использованием именованных атрибутов.

Несколько встроенных типов называются кортежами, включая значения, возвращаемые функциями `time.localtime()` и `os.stat()`. Другой пример - `sys.float_info`

Некоторые именованные кортежи являются встроенными типами. В качестве альтернативы именованный кортеж может быть создан из определения обычного класса, наследуемого от кортежа и определяющего именованные поля. Такой класс можно написать вручную или создать с помощью фабричной функции `collections.namedtuple()`.

## namespace

Место, где хранится переменная. Пространства имен реализованы в виде словарей. Существуют локальные, глобальные и встроенные пространства имен, а также вложенные пространства имен в объектах (в методах). Пространства имен поддерживают модульность, предотвращая конфликты имен.

Подробнее [[python-namespaces]]

## namespace package

Пакет, который служит только контейнером для подпакетов. Пакеты пространства имен могут не иметь физического представления и, в частности, не похожи на обычный пакет, потому что у них нет файла `__init__.py`.

## nested scope (вложенная область видимости)

Возможность ссылаться на переменную во вложенном определении. Например, функция, определенная внутри другой функции, может ссылаться на переменные во внешней функции. Вложенные области по умолчанию работают только для ссылок, а не для определения. Локальные переменные читаются и записываются в самой внутренней области. Точно так же глобальные переменные читаются и записываются в глобальном пространстве имен. `nonlocal` позволяет писать во внешние области видимости.

Подробнее [[python-namespaces]]

## path-like object

Объект, представляющий путь к файловой системе. Это либо объект `str` или `bytes`, представляющий путь, либо объект, реализующий протокол `os.PathLike`. Объект, поддерживающий протокол `os.PathLike`, может быть преобразован в путь файловой системы `str` или `bytes` путем вызова функции `os.fspath()`; Вместо них можно использовать `os.fsdecode()` и `os.fsencode()`, чтобы гарантировать результат `str` или `bytes` соответственно.

## qualified name

Doted имя, показывающее «путь» от глобальной области видимости модуля к классу, функции или методу, определенным в этом модуле. Для функций и классов верхнего уровня полное имя совпадает с именем объекта:

```python
>>> class C:
...     class D:
...         def meth(self):
...             pass
...
>>> C.__qualname__
'C'
>>> C.D.__qualname__
'C.D'
>>> C.D.meth.__qualname__
'C.D.meth'
```

При использовании для ссылки на модули полное имя означает весь путь к модулю, разделенный точками, включая все родительские пакеты:

```python
>>> import email.mime.text
>>> email.mime.text.__name__
'email.mime.text'
```

## `__slots__`

Объявление внутри класса, которое экономит память за счет предварительного объявления пространства для атрибутов экземпляра и исключения словарей экземпляра. Несмотря на популярность, этот метод довольно сложно реализовать, и его лучше всего использовать в редких случаях, когда в приложении, критичном к памяти, имеется большое количество экземпляров.

## sequence

Итерируемый объект, который поддерживает эффективный доступ к элементам с использованием целочисленных индексов через специальный метод `__getitem__()` и определяет метод `__len__()`, который возвращает длину последовательности.

`dict` также поддерживает `__getitem__()` и `__len__()`, но считается отображением, а не последовательностью, поскольку при поиске используются произвольные неизменяемые ключи, а не целые числа.

Абстрактный базовый класс `collections.abc.Sequence` определяет гораздо более богатый интерфейс, добавляя `count()`, `index()`, `__contains__()` и `__reversed __()`. Типы, реализующие этот расширенный интерфейс, могут быть зарегистрированы явно с помощью [register()](https://docs.python.org/3/library/abc.html#abc.ABCMeta.register).

## special method

Метод, который неявно вызывается Python для выполнения определенной операции с типом, например сложения. Такие методы имеют имена, начинающиеся и заканчивающиеся двойным подчеркиванием.

## statement (оператор)

Оператор - это либо выражение, либо одна из нескольких конструкций с ключевым словом, например `if`, `while` или `for`.

## strong reference

В CPython сильная ссылка - это ссылка на объект, которая увеличивает счетчик ссылок объекта при его создании и уменьшает счетчик ссылок объекта при его удалении.

## type alias (синоним типа)

```python
Color = tuple[int, int, int]

def remove_gray_shades(colors: list[Color]) -> list[Color]:
    pass
```

смотри [[type-annotation]]

[Полный глоссарий в документации python](https://docs.python.org/3/glossary.html#glossary)

[[python-standart-library]]

[//begin]: # "Autogenerated link references for markdown compatibility"
[python-filesystem]: python-filesystem "Работа с файлами"
[asyncio]: asyncio "Asyncio"
[threading]: threading "Threading"
[abc]: abc "Abc"
[asyncio]: asyncio "Asyncio"
[contextvars]: contextvars "Contextvars"
[python-descriptors]: python-descriptors "Python descriptors"
[python-datamodel]: ../lists/python-datamodel "Python datamodel"
[type-annotation]: type-annotation "Анотация типов в python"
[python-datamodel]: ../lists/python-datamodel "Python datamodel"
[python-sorting]: python-sorting "Python sorting"
[python-namespaces]: python-namespaces "Python namespaces"
[python-namespaces]: python-namespaces "Python namespaces"
[type-annotation]: type-annotation "Анотация типов в python"
[python-standart-library]: ../lists/python-standart-library "Стандартная библиотека python и полезные ресурсы"
[//end]: # "Autogenerated link references"
[//begin]: # "Autogenerated link references for markdown compatibility"
[python-filesystem]: python-filesystem "Работа с файлами"
[asyncio]: asyncio "Asyncio"
[threading]: threading "Threading"
[abc]: abc "Abc"
[asyncio]: asyncio "Asyncio"
[contextvars]: contextvars "Contextvars"
[python-descriptors]: python-descriptors "Python descriptors"
[python-datamodel]: ../lists/python-datamodel "Python datamodel"
[type-annotation]: type-annotation "Анотация типов в python"
[python-datamodel]: ../lists/python-datamodel "Python datamodel"
[python-sorting]: python-sorting "Python sorting"
[python-namespaces]: python-namespaces "Python namespaces"
[python-namespaces]: python-namespaces "Python namespaces"
[type-annotation]: type-annotation "Анотация типов в python"
[python-standart-library]: ../lists/python-standart-library "Стандартная библиотека python и полезные ресурсы"
[//end]: # "Autogenerated link references"