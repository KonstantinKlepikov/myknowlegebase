---
description: Dockerfile - конфиг контейнера
tags: docker
title: Dockerfile
---

Докер билдит контейнер автоматически с помощью. `docker build`, получая инструкции из Dockerfile и используя `context`.

Контекст сборки — это набор файлов в указанном месте `PATH` или `URL`. `PATH` — это каталог в вашей локальной файловой системе. `URL`-адрес — это расположение репозитория Git. Контекст сборки обрабатывается рекурсивно. Таким образом, PATH включает любые подкаталоги, а URL-адрес включает репозиторий и его подмодули.

Сборка выполняется демоном Docker, а не интерфейсом командной строки. Первое, что делает процесс сборки, это отправляет весь контекст (рекурсивно) демону. В большинстве случаев лучше начать с пустого каталога в качестве контекста и хранить файл Dockerfile в этом каталоге. Добавьте только те файлы, которые необходимы для создания Dockerfile. Не используйте свой корневой каталог `/` в качестве PATH для вашего контекста сборки, так как это приводит к тому, что сборка передает все содержимое вашего жесткого диска демону Docker.

Можно использовать флаг `-f`, чтобы указать на Dockerfile в любом месте вашей файловой системы.

```bash
docker build -f /path/to/a/Dockerfile .
```

Вы можете указать репозиторий и тег, в котором будет сохранен новый образ, если сборка пройдет успешно.

```bash
docker build -t shykes/myapp .

# for multyple repositories
docker build -t shykes/myapp:1.0.2 -t shykes/myapp:latest .
```

Перед запуском инструкции докер валидирует Dockerfile и поднимает ошибку, если синтаксис некорректен. Инструкции Dockerfile выполняются демоном одна за одной. Каждая инструкция запускается независимо и вызывает создание нового образа, поэтому `RUN cd /tmp` не окажет никакого влияния на следующие инструкции.

Когда это возможно, Docker использует кэш сборки, чтобы значительно ускорить процесс сборки Docker. На это указывает сообщение CACHED в выводе консоли. Опция `--cache-from` также позволяет вам использовать кеш сборки, который распространяется через реестр образов.

## Buildkit

BuildKit может:

- Обнаруживать и пропускать выполнение неиспользуемых этапов сборки
- Параллелизовать этапы сборки, не зависящие от сборки
- Поэтапно передавать только измененные файлы в контексте сборки между сборками
- Обнаруживать и пропускать передачу неиспользуемых файлов в контексте сборки
- Использовать внешние реализации Dockerfile со многими новыми функциями
- Избегать побочных эффектов (промежуточные образы и контейнеры)
- Устанавливать приоритет кэша сборки для автоматической обрезки.

BuildKit включается установкой `DOCKER_BUILDKIT=1` через CLI перед выполнением `docker build .`

С Buildkit можно использовать [syntax](https://docs.docker.com/engine/reference/builder/#syntax). Директива синтаксиса определяет расположение синтаксиса Dockerfile, который используется для создания Dockerfile.

Пользовательские реализации Dockerfile позволяют:

- Автоматически получать исправления ошибок без обновления демона Docker
- Быть уверенным, что все пользователи используют одну и ту же реализацию для создания вашего Dockerfil
- Использовать новейшие функции без обновления демона Docker
- Тестировать новые функции или сторонние функции до их интеграции в демоне Docker.
- Использовать альтернативные определения сборки или создайте свои собственные.

## Формат Dockerfile

- Инструкции не чувствительна к регистру, при этом есть соглашение писать прописными
- Dockerfile должен начинаться с инструкции `FROM` (это может быть после директив синтаксического анализатора, комментариев и глобальных ARG.)
- коментарии начинаются с `#`, если это не валидные директивы дял парсера
- [директивы парсера](https://docs.docker.com/engine/reference/builder/#parser-directives) не обязательны и влияют на то как обрабатываются последующие строки. Пишутся как комментарии специального типа в виде `# directive=value`. Директивы не отображаются при сборке и одна директива используется только однажды. После обработки комментария, пустой строки или инструкции по сборщику Docker больше не ищет директивы синтаксического анализатора, поэтому они должны быть как можно выше в Dockerfile. Директивы не чувствительны к регистру.

    ```Dockerfile
    # directive=value1
    # directive=value2

    FROM ImageName
    ```

- [escape директива](https://docs.docker.com/engine/reference/builder/#escape) устанавливает символ, используемый для экранирования символов в Dockerfile. Если он не указан, управляющим символом по умолчанию является \.

## Использование переменных окружения

Переменные, заданные в инструкции `ENV` могут использоваться в некоторых инструкциях Dockerfile. Синтаксис: `$variable_name` или `${variable_name}`. Кроме того, поддерживается некоторое количество модификаторов bash:

- `${variable:-word}` указывает, что если переменная установлена, результатом будет это значение. Если переменная не установлена, результатом будет word.
- `${variable:+word}` указывает, что если переменная установлена, результатом будет word, в противном случае результатом будет пустая строка.

Word может быть любой строкой, включающей в т.ч. переменные. Эскейпинг реализуется через `\`

```Dockerfile
FROM busybox
ENV FOO=/bar
WORKDIR ${FOO}   # WORKDIR /bar
ADD . $FOO       # ADD . /bar
COPY \$FOO /quux # COPY $FOO /quux
```

Переменные поддерживаются в след.инструкциях:

- ADD
- COPY
- ENV
- EXPOSE
- FROM
- LABEL
- STOPSIGNAL
- USER
- VOLUME
- WORKDIR
- ONBUILD

## .dockerignore file

.dockerignore просматривается перед отправкой контекста дкмону. Влияет на инструкции ADD и COPY

| Rule | Behavior |
|-|-|
| # comment | Ignored |
| */temp* | Exclude files and directories whose names start with temp in any immediate subdirectory of the root. For example, the plain file /somedir/temporary.txt is excluded, as is the directory /somedir/temp. |
| */*/temp* | Exclude files and directories starting with temp from any subdirectory that is two levels below the root. For example, /somedir/subdir/temporary.txt is excluded. |
| temp? | Exclude files and directories in the root directory whose names are a one-character extension of temp. For example, /tempa and /tempb are excluded. |

[Больше подробностей](https://docs.docker.com/engine/reference/builder/#dockerignore-file)

## Инеструкции

### [FROM](https://docs.docker.com/engine/reference/builder/#from)

```Dockerfile
FROM [--platform=<platform>] <image> [AS <name>]

# or
FROM [--platform=<platform>] <image>[:<tag>] [AS <name>]

# or
FROM [--platform=<platform>] <image>[@<digest>] [AS <name>]
```

Инструкция `FROM` инициализирует новую стадию сборки и устанавливает базовый образ для последующих инструкций. Таким образом, действительный файл Dockerfile должен начинаться с инструкции `FROM`.

- Перед `FROM` можно использовать только инструкцию `ARG`
- `FROM` может появляться несколько раз в одном Dockerfile для создания нескольких образов или использования одного этапа сборки в качестве зависимости для другого. Просто запишите идентификатор последнего изображения, выведенный фиксацией, перед каждой новой инструкцией `FROM`. Каждая инструкция `FROM` очищает любое состояние, созданное предыдущими инструкциями.
- При желании можно дать имя новому этапу сборки, добавив имя `AS` в инструкцию `FROM`. Это имя можно использовать в последующих инструкциях `FROM` и `COPY` `--from=<name>` для ссылки на образ, созданный на этом этапе.
- Значения тега или дайджеста являются необязательными. Если вы опустите любой из них, построитель по умолчанию примет последний тег. Билдер возвращает ошибку, если не может найти значение тега.
- Необязательный флаг `--platform` можно использовать для указания платформы образа в случае, если `FROM` ссылается на многоплатформенный образ

`ARG`, объявленная перед `FROM`, находится вне этапа сборки, поэтому ее нельзя использовать ни в одной инструкции после FROM. Чтобы использовать значение по умолчанию `ARG`, объявленное перед первым `FROM`, используйте инструкцию ARG без значения внутри этапа сборки

```Dockerfile
ARG VERSION=latest
FROM busybox:$VERSION
ARG VERSION
RUN echo $VERSION > image_version
```

### [RUN](https://docs.docker.com/engine/reference/builder/#run)

Два формата:

- `RUN <command>` (форма оболочки, команда запускается в оболочке, которая по умолчанию /bin/sh -c в Linux или cmd /S /C в Windows)
- `RUN ["executable", "param1", "param2"]` (exec form)

Инструкция `RUN` выполнит любые команды в новом слое поверх текущего изображения и зафиксирует результаты. Полученный зафиксированный образ будет использоваться для следующего шага в Dockerfile.

Форма exec позволяет выполнять команды с использованием базового образа, который не содержит указанный исполняемый файл оболочки. Дефолтный shell можно задать через команду `SHELL`

```Dockerfile
RUN /bin/bash -c 'source $HOME/.bashrc; \
echo $HOME'

# or
RUN /bin/bash -c 'source $HOME/.bashrc; echo $HOME'
```

Через exec можно задать другую оболочку

```Dockerfile
RUN ["/bin/bash", "-c", "echo hello"]
```

Форма exec анализируется как массив JSON, что означает, что вы должны использовать двойные кавычки (") вокруг слов, а не одинарные кавычки (').

В отличие от shell формы, форма exec не вызывает командную оболочку. Это означает, что нормальной обработки оболочки не происходит. Например, `RUN [ "echo", "$HOME" ]` не будет выполнять подстановку переменных в `$HOME`. Если вам нужна обработка оболочки, то либо используйте форму оболочки, либо запустите оболочку напрямую, например: `RUN [ "sh", "-c", "echo $HOME" ]`. При использовании формы exec и непосредственном выполнении оболочки, как и в случае с формой оболочки, расширение переменной среды выполняет оболочка, а не docker.

Кэш для инструкций `RUN` не становится недействительным автоматически во время следующей сборки. Кэш для такой инструкции, как `RUN apt-get dist-upgrade -y`, будет повторно использован во время следующей сборки. Кэш для инструкций RUN можно сделать недействительным с помощью флага `--no-cache`, например, `docker build --no-cache`.

### [CMD](https://docs.docker.com/engine/reference/builder/#cmd)

Три формы:

- `CMD ["executable","param1","param2"]` (exec form, this is the preferred form)
- `CMD ["param1","param2"]` (as default parameters to ENTRYPOINT)
- `CMD command param1 param2` (shell form)

В Dockerfile может быть только одна инструкция `CMD`. Если вы укажете более одного `CMD`, вступит в силу только последний `CMD`.

Основная цель `CMD` — предоставить значения по умолчанию для исполнения контейнера. Эти значения по умолчанию могут включать исполняемый файл или исключать исполняемый файл, и в этом случае вы также должны указать инструкцию `ENTRYPOINT`. Обе инструкции длолжны быть заданы с учетом формата json.

В отличие от shell формы, форма exec не вызывает командную оболочку. Это означает, что нормальной обработки оболочки не происходит.

Не путайте `RUN` с `CMD`. `RUN` фактически запускает команду и фиксирует результат; `CMD` ничего не выполняет во время сборки, но указывает запланированную команду для образа.

### [LABEL](https://docs.docker.com/engine/reference/builder/#label)

```Dockerfile
LABEL <key>=<value> <key>=<value> <key>=<value> ...
```

Инструкция `LABEL` добавляет к образу метаданные. `LABEL` — это пара ключ-значение. Чтобы включить пробелы в значение `LABEL`, используйте кавычки и обратную косую черту, как при синтаксическом анализе командной строки. Можно задать любое количество меток для образа.

```Dockerfile
LABEL "com.example.vendor"="ACME Incorporated"
LABEL com.example.label-with-value="foo"
LABEL version="1.0"
LABEL description="This text illustrates \
that label-values can span multiple lines."

LABEL multi.label1="value1" \
      multi.label2="value2" \
      other="value3"
```

Метки родителей наследуются. Если метка уже есть - используется последняя.

### [MAINTAINER (deprecated)](https://docs.docker.com/engine/reference/builder/#maintainer-deprecated)

### [EXPOSE](https://docs.docker.com/engine/reference/builder/#expose)

```Dockerfile
EXPOSE <port> [<port>/<protocol>...]
 ```

Открывает порты между контейнерами в сети в рантайм. Можно задать TCP или UDP.

Инструкция EXPOSE фактически не публикует порт. Он функционирует как тип документации между человеком, который создает образ, и человеком, который запускает контейнер, о том, какие порты предназначены для публикации. Чтобы фактически опубликовать порт при запуске контейнера, используйте флаг `-p` при запуске docker, чтобы опубликовать и сопоставить один или несколько портов, или флаг `-P`, чтобы опубликовать все открытые порты и сопоставить их с внешними портами.

### [ENV](https://docs.docker.com/engine/reference/builder/#env)

```Dockerfile
ENV <key>=<value> ...
```

Инструкция `ENV` устанавливает для переменной среды `<key>` значение `<value>`. Это значение будет в среде исполнения для всех последующих инструкций на этапе сборки и во многих случаях может быть заменено. Значение будет интерпретировано, поэтому символы кавычек будут удалены, если они не экранированы. Как и при синтаксическом анализе командной строки, для включения пробелов в значения можно использовать кавычки и обратную косую черту.

```Dockerfile
ENV MY_NAME="John Doe"
ENV MY_DOG=Rex\ The\ Dog
ENV MY_CAT=fluffy

ENV MY_NAME="John Doe" MY_DOG=Rex\ The\ Dog \
    MY_CAT=fluffy
```

Переменные среды, установленные с помощью `ENV`, будут сохраняться при запуске контейнера из полученного образа.

Если переменные нужны только при сборке - рассмотирте вариант установления их только для исполняемой команды

```Dockerfile
RUN DEBIAN_FRONTEND=noninteractive apt-get update && apt-get install -y ...

# or
ARG DEBIAN_FRONTEND=noninteractive
RUN apt-get update && apt-get install -y ...
```

### [ADD](https://docs.docker.com/engine/reference/builder/#add)

Две формы:

```Dockerfile
ADD [--chown=<user>:<group>] <src>... <dest>
ADD [--chown=<user>:<group>] ["<src>",... "<dest>"]
```

Последняя форма требуется для путей, содержащих пробелы.

Инструкция `ADD` копирует новые файлы, каталоги или URL-адреса удаленных файлов из `<src>` и добавляет их в файловую систему образа по пути `<dest>`. Можно указать несколько ресурсов `<src>`, но если они являются файлами или каталогами, их пути интерпретируются как относительные к источнику контекста сборки. Каждый `<src>` может содержать подстановочные знаки, и сопоставление будет выполняться с использованием правил Go's filepath.Match.

`<dest>` — это абсолютный путь или путь относительно `WORKDIR`, в который будет скопирован источник внутри целевого контейнера.

Пример для `<WORKDIR>/relativeDir/`:

```Dockerfile
ADD test.txt relativeDir/
```

Пример для `/absoluteDir/`:

```Dockerfile
ADD test.txt /absoluteDir/
```

Все новые файлы и каталоги создаются с UID и GID, равными 0, если только необязательный флаг `--chown` не указывает данное имя пользователя, имя группы или комбинацию UID/GID для запроса конкретного владельца добавленного контента.

```Dockerfile
ADD --chown=55:mygroup files* /somedir/
ADD --chown=bin files* /somedir/
ADD --chown=1 files* /somedir/
ADD --chown=10:11 files* /somedir/
```

Правила для `ADD`:

- Путь `<src>` должен находиться внутри контекста сборки; вы не можете ДОБАВИТЬ `../something/something`, потому что первым шагом сборки docker является отправка каталога контекста (и подкаталогов) демону docker.
- Если `<src>` является URL-адресом, а `<dest>` не заканчивается косой чертой, то файл загружается с URL-адреса и копируется в `<dest>`.
- Если `<src>` является URL-адресом, а `<dest>` заканчивается косой чертой, то имя файла выводится из URL-адреса, и файл загружается в `<dest>/<filename>`. Например, `ADD http://example.com/foobar/` создаст файл `/foobar`. URL-адрес должен иметь нетривиальный путь, чтобы в этом случае можно было обнаружить подходящее имя файла (`http://example.com` не будет работать).
- Если `<src>` является каталогом, копируется все содержимое каталога, включая метаданные файловой системы. Сам каталог не копируется.
- Если `<src>` является локальным tar-архивом в распознаваемом формате сжатия (identity, gzip, bzip2 или xz), то он распаковывается как каталог. Ресурсы с удаленных URL-адресов не распаковываются. Когда каталог копируется или распаковывается, он ведет себя так же, как tar -x.
- Если `<src>` является файлом любого другого типа, он копируется отдельно вместе со своими метаданными. В этом случае, если `<dest>` заканчивается косой чертой `/`, он будет считаться каталогом, а содержимое `<src>` будет записано в `<dest>/base(<src>)`.
- Если указано несколько ресурсов `<src>`, либо напрямую, либо из-за использования подстановочного знака, то `<dest>` должен быть каталогом, и он должен заканчиваться косой чертой `/`.
- Если `<dest>` не заканчивается косой чертой, он будет считаться обычным файлом, а содержимое `<src>` будет записано в `<dest>`.
- Если `<dest>` не существует, он создается вместе со всеми отсутствующими каталогами на его пути.

### [COPY](https://docs.docker.com/engine/reference/builder/#copy)

Две формы

```Dockerfile
COPY [--chown=<user>:<group>] <src>... <dest>
COPY [--chown=<user>:<group>] ["<src>",... "<dest>"]
```

Последняя форма требуется для путей, содержащих пробелы. `--chown` поддерживается только для Linux.

Инструкция `COPY` копирует новые файлы или каталоги из `<src>` и добавляет их в файловую систему контейнера по пути `<dest>`.

При желании `COPY` принимает флаг `--from=<name>`, который можно использовать для установки исходного местоположения на предыдущую стадию сборки (созданную с помощью `FROM .. AS <name>`), которая будет использоваться вместо контекста сборки, отправленного пользователем. В случае, если этап сборки с указанным именем не может быть найден, вместо него делается попытка использовать образ с таким же именем.

Правила:

- Путь `<src>` должен находиться внутри контекста сборки; вы не можете Ккопировать `../something/something`, потому что первым шагом сборки docker является отправка каталога контекста (и подкаталогов) демону docker.
- Если `<src>` является каталогом, копируется все содержимое каталога, включая метаданные файловой системы. Сам каталог не копируется, только его содержимое.
- Если `<src>` является файлом любого другого типа, он копируется отдельно вместе со своими метаданными. В этом случае, если `<dest>` заканчивается косой чертой `/`, он будет считаться каталогом, а содержимое `<src>` будет записано в `<dest>/base(<src>)`.
- Если указано несколько ресурсов `<src>`, либо напрямую, либо из-за использования подстановочного знака, то `<dest>` должен быть каталогом, и он должен заканчиваться косой чертой `/`.
- Если `<dest>` не заканчивается косой чертой, он будет считаться обычным файлом, а содержимое `<src>` будет записано в `<dest>`.
- Если `<dest>` не существует, он создается вместе со всеми отсутствующими каталогами на его пути.

Разница между `ADD` и `COPY` в том, что `ADD` умеет скачивать удаленные файлы и умеет разворачимвать архивы.

### [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint)

Две формы:

```Dockerfile
# exec
ENTRYPOINT ["executable", "param1", "param2"]

# shell
ENTRYPOINT command param1 param2
```

`ENTRYPOINT` позволяет настроить контейнер, который будет работать как исполняемый файл. Например, следующий код запускает nginx с содержимым по умолчанию, прослушивая порт 80:

```bash
docker run -i -t --rm -p 80:80 nginx
```

Аргументы командной строки для запуска `docker run <image>` будут добавлены после всех элементов в форме exec `ENTRYPOINT` и переопределят все элементы, указанные с помощью `CMD`. Это позволяет передавать аргументы в точку входа, т.е. `docker run <image> -d` передаст аргумент `-d` в точку входа. Вы можете переопределить инструкцию `ENTRYPOINT`, используя флаг `docker run --entrypoint`.

Shell форма предотвращает использование любых аргументов командной строки `CMD` или команд запуска, но имеет тот недостаток, что ваша `ENTRYPOINT` будет запущена как подкоманда `/bin/sh -c`, которая не передает сигналы. Это означает, что исполняемый файл не будет иметь `PID 1` контейнера и не будет получать сигналы Unix, поэтому ваш исполняемый файл не получит `SIGTERM` от `docker stop <container>`.

Всегда применяется только последняя инструкция `ENTRYPOINT`

Вы можете использовать форму exec `ENTRYPOINT`, чтобы установить довольно стабильные команды и аргументы по умолчанию, а затем использовать любую форму `CMD`, чтобы установить дополнительные значения по умолчанию, которые, скорее всего, будут изменены. [Подробнее](https://docs.docker.com/engine/reference/builder/#exec-form-entrypoint-example)

Вы можете указать простую строку для `ENTRYPOINT`, и она будет выполняться в `/bin/sh -c`. Эта форма будет использовать обработку оболочки для замены переменных среды оболочки и игнорировать любые аргументы командной строки `CMD` или `docker run`. Чтобы гарантировать, что `docker stop` будет правильно сигнализировать о любом длительно работающем исполняемом файле `ENTRYPOINT`, вам нужно не забыть запустить его с помощью `exec`. [Пример](https://docs.docker.com/engine/reference/builder/#shell-form-entrypoint-example)

И инструкции `CMD`, и `ENTRYPOINT` определяют, какая команда будет выполняться при запуске контейнера. Есть несколько правил, описывающих их взаимодействие:

- Dockerfile должен указывать хотя бы одну из команд `CMD` или `ENTRYPOINT`.
- `ENTRYPOINT` должен быть определен при использовании контейнера в качестве исполняемого файла.
- `CMD` следует использовать как способ определения аргументов по умолчанию для команды `ENTRYPOINT` или для выполнения специальной команды в контейнере.
- `CMD` будет переопределен при запуске контейнера с альтернативными аргументами.

В таблице ниже показано, какая команда выполняется для разных комбинаций `ENTRYPOINT/CMD`:

| | No ENTRYPOINT | ENTRYPOINT exec_entry p1_entry | ENTRYPOINT [“exec_entry”, “p1_entry”] |
|-|-|-|-|
| No CMD | error, not allowed | /bin/sh -c exec_entry p1_entry | exec_entry p1_entry |
| CMD [“exec_cmd”, “p1_cmd”] | exec_cmd p1_cmd | /bin/sh -c exec_entry p1_entry | exec_entry p1_entry exec_cmd p1_cmd |
| CMD [“p1_cmd”, “p2_cmd”] | p1_cmd p2_cmd | /bin/sh -c exec_entry p1_entry | exec_entry p1_entry p1_cmd p2_cmd |
| CMD exec_cmd p1_cmd | /bin/sh -c exec_cmd p1_cmd | /bin/sh -c exec_entry p1_entry | exec_entry p1_entry /bin/sh -c exec_cmd p1_cmd |

### [VOLUME](https://docs.docker.com/engine/reference/builder/#volume)

```Dockerfile
VOLUME ["/data"]
```

Инструкция `VOLUME` создает точку монтирования с указанным именем и помечает ее как содержащую внешне смонтированные тома из собственного хоста или других контейнеров. Значение может быть массивом `JSON`, `VOLUME ["/var/log/"]` или простой строкой с несколькими аргументами, например `VOLUME /var/log` или `VOLUME /var/log /var/db`. [Use volumes](https://docs.docker.com/storage/volumes/)

Команда `docker run` инициализирует только что созданный том любыми данными, которые существуют в указанном месте в базовом образе.

- Тома в контейнерах на базе Windows: при использовании контейнеров на базе Windows место назначения тома внутри контейнера должно быть одним из: несуществующий или пустой каталог или диск, отличный от C:
- Изменение тома из Dockerfile: если какие-либо шаги сборки изменят данные внутри тома после его объявления, эти изменения будут отменены.
- Форматирование JSON: список анализируется как массив JSON. Вы должны заключать слова в двойные кавычки (""), а не в одинарные кавычки (').
- Каталог хоста объявляется во время выполнения контейнера: каталог хоста (точка монтирования) по своей природе зависит от хоста. Это делается для сохранения переносимости образа, поскольку нельзя гарантировать, что данный каталог хоста будет доступен на всех хостах. По этой причине вы не можете смонтировать каталог хоста из Dockerfile. Инструкция `VOLUME` не поддерживает указание параметра host-dir. Вы должны указать точку монтирования при создании или запуске контейнера.

### [USER](https://docs.docker.com/engine/reference/builder/#user)

```Dockerfile
USER <user>[:<group>]

# or
USER <UID>[:<GID>]
```

Инструкция `USER` устанавливает имя пользователя (или UID) и, при необходимости, группу пользователей (или GID) для использования при запуске образа и для любых инструкций `RUN`, `CMD` и `ENTRYPOINT`, которые следуют за ней в Dockerfile.

### [WORKDIR](https://docs.docker.com/engine/reference/builder/#workdir)

```Dockerfile
WORKDIR /path/to/workdir
```

Инструкция `WORKDIR` устанавливает рабочий каталог для любых инструкций `RUN`, `CMD`, `ENTRYPOINT`, `COPY` и `ADD`, которые следуют за ней в Dockerfile. Если `WORKDIR` не существует, он будет создан, даже если он не используется ни в одной последующей инструкции Dockerfile.

Инструкцию `WORKDIR` можно использовать несколько раз в Dockerfile. Если указан относительный путь, он будет относиться к пути предыдущей инструкции `WORKDIR`.

```Dockerfile
WORKDIR /a
WORKDIR b
WORKDIR c
RUN pwd
```

`WORKDIR` поддерживает переменные

```Dockerfile
ENV DIRPATH=/path
WORKDIR $DIRPATH/$DIRNAME
RUN pwd
```

Дефолтный `WORKDIR` - `/`. Поэтому, чтобы избежать непреднамеренных операций в неизвестных каталогах, лучше всего указать свой `WORKDIR` явно.

Смотри еще:

- [dockerfile references](https://docs.docker.com/engine/reference/builder/)
- [[docker]]
- [[docker-compose]]

[//begin]: # "Autogenerated link references for markdown compatibility"
[docker]: ../lists/docker "Docker"
[docker-compose]: docker-compose "Docker compose"
[//end]: # "Autogenerated link references"