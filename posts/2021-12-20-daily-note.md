---
title: Операторы сравнения, запуск модуля с аругментами и др.тонкости python
description: В каком порядке разрешаются операторы при сравнении объектов? Как запускать модуль с аргументами? Немного про порядок импорта и пара нюансов встроенных функций
category: post
---
## Приоритет сравнения в python

Числовые операторы: `==`, `<=`, `>=`, `<`, `>`, `!=`.

Операторы сравнения `in` и `not in` проверяют, встречается ли значение (не встречается) в последовательности. Операторы сравнивают `is` и `is not` сравнивают, действительно ли два объекта являются одним и тем же объектом. Все операторы сравнения имеют одинаковый приоритет, который ниже, чем у всех числовых операторов.

Сравнения можно объединить в цепочку. Например, `a < b == c` проверяет, меньше ли a, чем b, и, кроме того, b равно c.

Сравнения могут быть объединены с использованием логических операторов `and` и `or`, а результат сравнения (или любого другого логического выражения) может быть инвертирован с помощью `not`. У них более низкий приоритет, чем у операторов сравнения. При этом у логических операторов `not` имеет наивысший приоритет `and`/`or` самый низкий.

Например `A and not B or C` эквивалентно `(A and (not B)) or C`.

Круглые скобки могут использоваться для обозначения желаемой композиции и желательно использовать скобки для упрощения понимания конструкции сравнения.

Логические операторы и операторы `and`/`or` являются операторами короткого замыкания: их аргументы оцениваются слева направо, и оценка прекращается, как только определен результат, соответствующий условий.

При использовании в качестве результата расчета, а не для выяснения истинности утверждения, оператор короткого замыкания вернет последний участвовавший в вычислениях аргумент.

Результат сравнения или другое логическое выражение можно присвоить переменной.

```python
>>> string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'
>>> non_null = string1 or string2 or string3
>>> non_null
'Trondheim'
```

Присвоение внутри выражений должно выполняться явно с помощью оператора моржа `:=` для python3.10 и выше.

## Запуск модуля с аргументами

```python
def my(h):
    return n + 1

if __name__ == "__main__":
    import sys
    my(int(sys.argv[1]))
```

```shell
$ python mymodule.py 50
51
```

## Получить список ключей словаря

```python
>>> d = {1: 123, 3: 456, 17: 879, 14: 111}
>>> print(list(d))
[1, 3, 17, 14]
```

отсортированный

```python
>>> print(sorted(d))
[1, 3, 14, 17]
```

## Порядок импорта модулей и пакетов

Поиск путей осуществляется в следующем порядке:

- в списке встроенных модулей
- в списке каталогов, заданном в `sys.path`.

При этом `sys.path` инициализируется из следующих мест:

- каталог, содержащий входящий скрипт (или текущий каталог, если файл не указан).
- PYTHONPATH (список имен каталогов с тем же синтаксисом, что и переменная оболочки PATH).
- зависимости, определенные по дефолту установкой python (по соглашению включая каталог `site-packages`, управляемый модулем [site](https://docs.python.org/3/library/site.html#module-site)).

В файловых системах, поддерживающих символические ссылки, каталог, содержащий входящий скрипт, вычисляется после перехода по символической ссылке. Другими словами, каталог, содержащий символическую ссылку, не добавляется в путь поиска модуля.

После инициализации программы Python может изменять `sys.path`. Каталог, содержащий запускаемый скрипт, помещается в начало пути поиска, перед стандартным путем к библиотеке. Это означает, что скрипты в этом каталоге будут загружены вместо модулей, если их имена совпадают. Это может вести к ошибкам, если такое поведение не проектируется.

Для импорта пакетов доступно две конструкции

```python
import this.that.then

from this.that.then import All
```

При использовании `from` элемент может быть либо подмодулем (или подпакетом) пакета, либо каким-либо другим именем, определенным в пакете, например функцией, классом или переменной. Оператор импорта сначала проверяет, определен ли элемент в пакете; в противном случае он предполагает, что это модуль, и пытается его загрузить. Если его не удается найти, возникает исключение `ImportError`. Напротив, при использовании синтаксиса типа `import item.subitem.subsubsubitem` каждый элемент, кроме последнего, должен быть пакетом; последний элемент может быть модулем или пакетом, **но не может быть классом, функцией или переменной, определенной в предыдущем элементе**.

Можно использовать относительный импорт, но он основан на имени текущего модуля. Поскольку имя основного модуля всегда `__main__`, модули, предназначенные для использования в качестве основного модуля приложения Python, всегда должны использовать абсолютный импорт.

## dir()

Без аргументов `dir()` возвращает имена, определенные в текущем пространстве имен. Если передать название модуля - возвращает пространство имен модуля. `dir()` не возвращает имена встроенных функций - чятобы получить их используй:

```python
>>> import builtins
>>> dir(builtins)
```

[[python-standart-library]]

[//begin]: # "Autogenerated link references for markdown compatibility"
[python-standart-library]: ../lists/python-standart-library "Стандартная библиотека python и полезные ресурсы"
[//end]: # "Autogenerated link references"