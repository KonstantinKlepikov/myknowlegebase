---
title: Кастомные классы от python-словаря
description: Custom dict-subclasses
category: post
tags: python
---
## How to subclass a dictionary so it supports generic type hints?

[overflow](https://stackoverflow.com/a/64323140/15966204)

```python
from collections import abc  # Used for isinstance check in `update()`.
from typing import Dict, Iterator, MutableMapping, TypeVar

KT = TypeVar('KT')
VT = TypeVar('VT')


class MyDict(MutableMapping[KT, VT]):

    def __init__(self, dictionary=None, /, **kwargs) -> None:
        self.data: Dict[KT, VT] = {}
        if dictionary is not None:
            self.update(dictionary)
        if kwargs:
            self.update(kwargs)

    def __contains__(self, key: KT) -> bool:
        return key in self.data

    def __delitem__(self, key: KT) -> None:
        del self.data[key]

    def __getitem__(self, key: KT) -> VT:
        if key in self.data:
            return self.data[key]
        raise KeyError(key)

    def __len__(self) -> int:
        return len(self.data)

    def __iter__(self) -> Iterator[KT]:
        return iter(self.data)

    def __setitem__(self, key: KT, value: VT) -> None:
        self.data[key] = value

    @classmethod
    def fromkeys(cls, iterable: Iterable[KT], value: VT) -> "MyDict":
        """Create a new dictionary with keys from `iterable` and values set
        to `value`.

        Args:
            iterable: A collection of keys.
            value: The default value. All of the values refer to just a single
                instance, so it generally does not make sense for `value` to be a
                mutable object such as an empty list. To get distinct values, use
                a dict comprehension instead.

        Returns:
            A new instance of MyDict.
        """
        d = cls()
        for key in iterable:
            d[key] = value
        return d

    def update(self, other=(), /, **kwds) -> None:
        """Updates the dictionary from an iterable or mapping object."""
        if isinstance(other, abc.Mapping):
            for key in other:
                self.data[key] = other[key]
        elif hasattr(other, "keys"):
            for key in other.keys():
                self.data[key] = other[key]
        else:
            for key, value in other:
                self.data[key] = value
        for key, value in kwds.items():
            self.data[key] = value
```

## Dot . access

[source](https://stackoverflow.com/a/32107024/15966204)

```python
class Map(dict):
    """
    Example:
    m = Map({'first_name': 'Eduardo'}, last_name='Pool', age=24, sports=['Soccer'])
    """
    def __init__(self, *args, **kwargs):
        super(Map, self).__init__(*args, **kwargs)
        for arg in args:
            if isinstance(arg, dict):
                for k, v in arg.iteritems():
                    self[k] = v

        if kwargs:
            for k, v in kwargs.iteritems():
                self[k] = v

    def __getattr__(self, attr):
        return self.get(attr)

    def __setattr__(self, key, value):
        self.__setitem__(key, value)

    def __setitem__(self, key, value):
        super(Map, self).__setitem__(key, value)
        self.__dict__.update({key: value})

    def __delattr__(self, item):
        self.__delitem__(item)

    def __delitem__(self, key):
        super(Map, self).__delitem__(key)
        del self.__dict__[key]
```

Смотри еще:

- [[python-standart-library]]
- [[typing]]

[//begin]: # "Autogenerated link references for markdown compatibility"
[python-standart-library]: ../lists/python-standart-library "Стандартная библиотека python и полезные ресурсы"
[typing]: ../notes/typing "Typing"
[//end]: # "Autogenerated link references"