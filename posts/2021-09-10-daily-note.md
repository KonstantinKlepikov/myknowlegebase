---
title: Как получить имя ошибки в python и немного про то, как импортить собственные скрипты на kaggle
description: How to get the name of an exception that was caught in Python плюс немного про kaggle
category: post
---
## How to get the name of an exception that was caught in Python

[Ссылка на оверфло](https://stackoverflow.com/a/18176682/15966204)

Три варианта:

- `type(exception).__name__`
- `exception.__class__.__name__`
- `exception.__class__.__qualname__`

Пример реализации

```python
try:
    foo = bar
except Exception as exception:
    assert type(exception).__name__ == 'NameError'
    assert exception.__class__.__name__ == 'NameError'
    assert exception.__class__.__qualname__ == 'NameError'
```

Смотри в дополнение про то, как получить сообщение ошибки в виде строки [[2021-06-04-daily-note]]

## Feature Launch: Import scripts into notebook kernels

Скажем так, не сильно полезная фича, т.к. нет возможности выстроить настоящую структуру пакета, а импорт ограничивается ноутом. Ну и плюс все это надо делать руками через jupyter notebook. Но, если есть какие-то сильно часто встречающиеся куски кода, то можно попробовать так реализовать.

- Create a script kernel with the code you’d like to import.
- Under the "File" menu, click on "Make Utility Script". This will let you import this script to notebook kernels.
- Commit your script. When you import a script, you’re importing the most recent committed version. If you haven’t committed a version yet, you won’t see it in the list of scripts you can import.
- Open the notebook where you’d like to import the script.
- Add the script. Under “File”, click “Add utility script”. Search for the script you want and click to add it. You should see it listed under “usr/lib” in the panel on the right hand side.
- Import your script. In Python you can do this using `import nameof_script`.
- Use the functions or objects you’ve imported!

- a utility script can be a combination of multiple code snippets in different source files
- be able to add data/non-code related files as part of the utility function
- allow folder structure where code and data can reside in a structured fashion
- allow access to the data area of the notebook via an environment variable or some other method
- allow linking a gist where the code can reside (gist will contain the code for the utility script)
- allow linking a git repo (via branch or commit points) - will contain the code for the utility script)
- allow linking only a folder in a git repo where the code and data resides
  
**The above will help in the following ways:**

- keep the main utility script small, simple and modular
- easy to read, change and use
- can be version controlled via another public SCM system while still visible to the kernel
- keep components of the utility script separate from the data or configuration files in an organised manner

[Какое-то там обсуждение на эту тему](https://www.kaggle.com/product-feedback/91185)

[//begin]: # "Autogenerated link references for markdown compatibility"
[2021-06-04-daily-note]: 2021-06-04-daily-note "Как получить текст ошибки в python и немного про pylance в vscode"
[//end]: # "Autogenerated link references"