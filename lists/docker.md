# Docker

## Начало работы

`docker version`
`docker run debian echo 'hello world'`

В данном случае запускается образ debian (если его нет, он будет загружен с докерхаба) - упрощенный дестрибутив линукс. После загрузки и проверки образа он помещается в контейнер. Затем выполняется echo.

Запуск баша внутри контейнера: `docker run -i -t debian /bin/bash` (не заработал ui в vscode - видимо надо погуглить баг)

Зададим имя хоста: `docker run -h CONTAINER -i -t debian /bin/bash` а вот так заработал

Инфа по конкретному контейнеру: `docker inspect short_pseudonime`

Более короткий вывод через grep, например ip: `docker inspect short_pseudonime | grep IPAddress`

Или через `--format`: `docker inspect --format {{.NetworkSettings.IPAddress}} short_pseudonime`

Список файлов, которые были измсененеы в работающем контейнере: `docker diff short_pseudonime`

Список всех событий, произошедших внутри контейнера: `docker logs short_pseudonime`

Остановить контейнера: `exit`

Удаление всех остановленных контейнеров: `docker rm -v $(docker ps -aq -f status=exited)`

Удалить отдельный контейнер очень просто `docker rm short_pseudonime`

Проще всего вести раборту с докером через Dockerfile - это простой текстовый файл, в котором прописан скрипт, который будет выполнен при создании нового образа. Т.е. вначале мы создаем контейнер, а затем из него новый образ. Например такой докерфайл:

```Dockerfile
FROM debian
RUN apt-get update && apt-get install -y cowsay fortune
```

Инструкция FROM определяет базовый образ ОС - эта инструкция строго обязательна. RUN определяет команды, выполняемые в оболочке.

Теперь можно создавать образ с помощью `docker build` с помощью Dockerfile: `docker build -t test/cowsay-dockerfile`. Аналогично эту процедуру можно реализовать через run, команды в шеле внутри контейнера и docker commit.

Теперь можно запускать образ так-же, как и любой другой образ.

`docker run test/cowsay-dockerfile /usr/games/cowsay "Moo"`

![moo](../attachments/2021-06-07-23-15-44.png)

Все доп.команды, которые мы используем для запуска контейнера можно добавить в докерфайл - тогда они станут исполняться при запуске контейнера. При изменеении докерфайла требуется пересоздание образа.

```Dockerfile
FROM debian
RUN apt-get update && apt-get install -y cowsay fortune

ENTRYPOINT ["/usr/games/cowsay"]
```

`docker build -t test/cowsay-dockerfile`

Теперь входим так:

`docker run test/cowsay-dockerfile "Moo"`

Если создать рядом с докерфайлом entrypoint.sh, то можно получить некие исполняемые скрипты, в данном случае - доступ к потоку ввода/вывода. Теперь мы можем заменить и ентрипоинт (не забудь выдать права файлу entrypoint.sh. как исполняемому)

```Dockerfile
FROM debian
RUN apt-get update && apt-get install -y cowsay fortune
COPY entrypoint.sh /

ENTRYPOINT ["/entrypoint.sh"]
```

```sh
#!/bin/bash
if [ $# -eq 0 ]; then
        /usr/games/fortune | /usr/games/cowsay
    else
        /usr/games/cowsay "$@"
fi
```

Инструкция COPY прост окопирует файл из файловой системы хоста в файловую систему образа. Первый аргумент - файл хоста, второй - путь в образе.

![moo](../attachments/2021-06-07-23-33-09.png)

Работа с репозиториями образов ведется с помощью build, pull, push

## Архитектура docker

- Docker daemon - создание, запуск и контроль контейнеров, создание и хранение образов
  клиет docker используется для диалога с демоном по протоколу http. По умолчанию соединение устанавливается через сокет домена unix, но овзможны и другие. С демоном можно взаимодействовать напрямую, без использования клиента docker
- реестры docker используются для хранения и распространения образов

Сопровождающие технологии:

- docker swarm - решение задачи кластеризации, позволяет сгруппировать несколько docker-хостов
- docker compose - создание и выполнение приложений, скомпонованных из нескольких контейнеров. В основном нужно для теста и разработки, реже на проде.
- docker machine - устанавливает и конфигурирует хосты на локальных и удаленных машинах
- kinematic - гиу ждя маков и win
- docker trusted registry - локальное хранилище образов (локальный docker hub)

## Создание образов

Для создания образа требуется Dockerfile и контекст создания образа (build context). Контекст - это набор локальных папок и файлов, к которым можно обращаться из инструкции ADD и COPY Dockerfile и который обвчно определяется как путь к нужному каталогу. К примеру `docker bild -t test/cowsay=dockerfile .` определят контекст как `.`, т.е. текущий рабочий каталог. Все файлы и каталоги в этом пути формируют контекст создания образа и передаются в демон Docker как часть процесса создания. В случаях, когда контекст не определен, он считается пустым.

`/` не следует использовать в качестве контекста, т.к. все будет включено в образ :)

В качестве контекста допускается использовать git-репозиторий. В этом случае делается клон репоизитория и всех подчиненных репозиториев во временный каталог, который затем передается в демон как контекст.

Кроме того, контекст можно получить из стандартного потока ввода STDN

Для удаления ненужных файлов используется `.dockerignore`

При создании образа используются уровни - каждая инструкция в Dockerfile приводит к появлению такого уровня, который так же может участвовать в запуске контейнера. Новый уровень создается по время запуска контейнера с использованием образа предыдущего уровня, с сохранением нового образа. После успешного выполнения инструкции Dockerfile, вспомогательный контейнер удаляется, все активные процессы завершаются. Если необходим сервис или процесс, который юудет жить дольше, его необходимо инициализировать с помощью ENTRYPOINT или CMD. Весь набор уровней можно увидеть через `docker history`. При неудачном создании образа полезно запустить уровень, предыдущий ошибке.

Кроме того, используется кэширование для оптимизации производительности. Кэширование можно запрещать, так как не гарантируется получение одинакового результата для ряда команд.

При создании собственного образа необходимо использовать один из базовых образов.

`docker build` собирает образ, вызывая базовый сначала локально. Если его нет - удаленно. Это означает, что самая новая версия не гарантируется - необходимо явно выполнить `docker pull` для родительских образов или удалить их.

## Инструкции Dockerfile

Допускается использование формата командной оболочики или exec в инструкциях RUN, CMD, ENTRYPOINT

- ADD - копирует файлы из контекста или по удаленным урлам в образ. Если архивный файл добавляется из локального пути, то он распаковывается.
- CMD - запускает заданную инструкцию во время инициализации контейнера. Если определен ENTRYPOINT, то инструкция будет интерпретирована как аргумент для entrypoint. Инструкция заменяется тем, что введено в командной строке... если указано несколько инструкций, будет выполнена только самая последняя.
- COPY - копирует файлы из контекста в образ
- ENTRYPOINT - определяет выполняемый файл. запускаемый при инициализации контейнера
- ENV - определяет переменныесреды внутри образа. На них можно ссылаться в инструкциях
- EXPOSE - задает прослшивание портов в контейнере - это нужно для установления соединения между контейнерами
- FROM - определяет основной(базовый) образ. Все последующие инструцкции выполняются поверх. Задается в формате IMAGE:TAG, если нет тега, ставится latest. **Рекомендуется явно указывать тег**.
- ONBUILD - определяет инструкцию, которая будет выполняться, если этот образ будет использоваться как основной уровень для другого образа
- RUN - запускает инструкцию внутри контейнера и сохраняет результата
- USER - юзер
- VOLUME - объявляет файл или какталог как том
- WORKDIR  - рабочий каталог для всех последующих инструкций Dockerfile

## Открытие портов контейнера
