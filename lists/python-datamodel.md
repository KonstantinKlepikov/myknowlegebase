---
description: Модель данных в python
tags: python-standart-library
---
# Python datamodel

## Объекты, значения и типы

У каждого объекта в python есть id, имя и значение. Объект можно представить через адрес в памяти - его идентичность никогда не меняется после создания - `is` сравнивает идентичность, а `id()` возвращает айдишник объекта (в CPython это представление адреса в памяти).

Тип объекта определяет операции, которые поддерживаются объектом и возможные значения объекта. `type()` возвращает тип объекта. Значение типа может меняться после создания объекта - объекты с иззменяемыми типами называются изменяемыми. При этом объекты-контейнеры с неизменяемым типом (к примеру кортежи) могут "содержать" объекты с изменяемым типом. Контейнеры содержат не сами объекты, а ссылки на них, поэтому при изменеении объектов, на которые указывают ссылки контейнеров, следует ожидать изменеения и при вызове контейнеров.

Объекты в python не уничтожаются явным способом, но при отсутствии ссылок на них, их может собрать сборщик мусора. CPython использует схему подсчета ссылок с отложенным подсчетом циклических ссылок, что обеспечивает удаление большинства объектов, на которые никто не ссылается... но не гарантирует удаление всех подобных объектов. Трассировака, отладка и перехват исключений с помощью `try... except` могут приводить к сохранению ссылок на объекты. Всегда следует явно закрывать открытые файлы через `close()` (если предоставлен), `try... finally` или менеджеры контекста `with...`

### Иерархия типов

1. `None` используется для обозначения отсутствия значения
2. `NotImplemented` численные методы и методы сравнения должны возвращать этот тип, если они не реалоизуют операцию для представленных операндов. Данный тип не следует использовать в логическом контексте
3. `Ellipsis` многоточие `...`
4. [numbers.Number](https://docs.python.org/3/library/numbers.html#numbers.Number). Все числовые типы неизменяемы

- Строковее представление подчиняется следующим правилам:
  - это действительные числовые литералы, которые при передаче их конструктору класса создают объект, имеющий значение исходного числа
  - если возможно, представление выполняется в базе 10
  - начальные нули, за исключением, возможно, одного нуля перед десятичной точкой, не отображаются
  - завершающие нули, за исключением, возможно, одного нуля после десятичной точки, не отображаются
  - знак отображается только тогда, когда число отрицательное.
- [numbers.Integral](https://docs.python.org/3/library/numbers.html#numbers.Integral) целые числа
  - [int](https://docs.python.org/3/library/functions.html#int) целые числа в неограниченном диапазоне (верхний предел ограничен памятью).
  - [bool](https://docs.python.org/3/library/functions.html#bool) логические числа `False/True`, ведут себя как 0 и 1 за исключением преобразования в строку
- [numbers.Real](https://docs.python.org/3/library/numbers.html#numbers.Real) реализуют [float](https://docs.python.org/3/library/functions.html#float) числа с плавающей точкой двойной точности машинного уровня, которая зависит от реализации интерпретаттора.
- [numbers.Complex](https://docs.python.org/3/library/numbers.html#numbers.Complex) реализует [complex](https://docs.python.org/3/library/functions.html#complex) комплексные числа как пару float чисел. Обе части для числа z можно получить так: `z.real` и `z.imag`

5. Sequences - конечные упорядоченные наборы объектов, индексированные неотрицательными числами. Последовательность имеет длину, поддерживает операцию нарезки (в т.ч. расширенную, с шагом).

- Неизменяемые
  - Strings последовательность значений Unicode символов
  - Tuples последовательность произвольных объектов python
  - Bytes последовательность состоящая из объектов байтов (неизменяемые объекты длиной 8 бит, состоящие из чисел в диапазоне 0<\X<=256)
- Изменяемые
  - Lists
  - Byte Arrays
  
6. Sets - конечные неупорядоченные наборы уникальных неизменяемых объектов. Не индексируются. Имеют длину.

- Sets изменяемый тип
- Frozen sets неизменяемые

7. Mappings (отображения) - конечные наборы объектов, индексированные произвольным набором индексов. Имеют длину.

- Dicts - для индекса словарей неприменимы объекты, содержащие изменяемые типы, которые сравниваются по значению, а не по хешу. Это связано с тем, что хеш ключа должен быть неимзенным. Начиная с 3.6 словари сохраняют порядок вставки, а замена ключа не меняет порядок, однако удаление и новая вставка добавляет ключ в конец.

Пример с использованием двух чисел, имеющих одинаковый хеш, провоцирующий неожиданное поведение.

```python
>>> d = {1: 100, 1.0: 200}
>>> print(d)

{1: 200}
```

8. Calable tipes - типы, к которым можно применить [операцию вызова](https://docs.python.org/3/reference/expressions.html#calls). Это пользовательские функции, методы встроенных классов, объекты классов, методы экземпляров классов и все объекты, реализующие  метод `__call__()`.

Аргументы вызываемых типов оцениваются до вызова следующим образом: первым делом создается список незаполненных слотов для параметров. Если имеется N позиционных аргументов, они помещаются в первые N слотов. Если присутствуют ключевые аргументы, они преобразуются в позиционные аргументы. Для каждого ключевого аргумента его идентификатор используется для определения соответствующего слота (если идентификатор совпадает с именем первого формального параметра, используется первый слот и т. д.). Если слот уже заполнен, возникает исключение TypeError. В противном случае значение аргумента помещается в слот, заполняя его. Когда все аргументы обработаны, пустые слоты заполняются соответствующим значением по умолчанию из определения функции. Значения по умолчанию вычисляются один раз, когда функция определена; таким образом, изменяемые объекты, используемые в качестве значений по умолчанию, будут использованы всеми вызовами, что может привести к нежелательному поведению. Если есть какие-либо незаполненные слоты, для которых не указано значение по умолчанию, возникает исключение TypeError. В противном случае список заполненных слотов используется в качестве списка аргументов для вызова.

Попытка переопределить уже заполненный слот

```python
>>> def my(a, b, c=4):
...     print(a + b + c)
    
>>> my(1, 2, b=3)
Traceback (most recent call last):
  File "<string>", line 4, in <module>
TypeError: my() got multiple values for argument 'b'
```

Использование изменяемого объекта при повторных вызовах

```python
>>> def my(a, b=[]):
...     print(b)
...     b.append(a)
...     print(b)
    
>>> my(1)
[]
[1]
>>> my(2)
[1]
[1, 2]
```

Основные типы вызываемых объектов:

- User-defined functions (пользорвательские функции) создаются определением функции со списком аргументов, содержащим тоже кол-во аргументов, что и формальных параметров функции. Специфические атрибуты представлены ниже

| Атрибут | Значение | |
|-|-|-|
| `__doc__` | Строка документации функции или, None если она недоступна; не наследуется подклассами | запись/чтение |
| `__name__` | Имя функции | запись/чтение |
| `__qualname__` | [Квалифицированное имя](https://docs.python.org/3/glossary.html#term-qualified-name) - включающее путь от глобальной области видимости | запись/чтение |
| `__module__` | Имя модуля, в котором функция была определена, или None если он недоступен | запись/чтение |
| `__defaults__` | Кортеж, содержащий значения аргументов по умолчанию для тех аргументов, которые имеют значения по умолчанию, или None если аргументы не имеют значения по умолчанию | запись/чтение |
| `__code__` | Объект кода, представляющий тело скомпилированной функции | запись/чтение |
| `__globals__` | Ссылка на словарь, содержащий глобальные переменные функции - глобальное пространство имен модуля, в котором функция была определена | только чтение |
| `__dict__` | Пространство имен, поддерживающее атрибуты функции | запись/чтение |
| `__closure__` | None или кортеж, содержащий привязки замыканий | только чтение |
| `__annotations__` | Словарь с аннотациями параметров. Ключи - это имена параметров и 'return' для аннотации возврата, если она есть | запись/чтение |
| `__kwdefaults__` | Словарь, содержащий значения по умолчанию для ключевых параметров. Если мы не определим * между позиционными и ключевыми параметрами, то вместо словаря будет `None`... а если определим, то `None` будет в `__defaults__` | запись/чтение |

Пример

```python
>>> z = 3
>>> def my(a: int, *, b: int = 3) -> int:
...     """This is doc"""
...     def this():
...         return a + b + z
...     return this
    
>>> print(my.__doc__)\
This is doc  
>>> print(my.__name__)
my
>>> print(my.__qualname__)
my
>>> print(my.__module__)
__main__
>>> print(my.__defaults__)
None
>>> print(my.__code__)
<code object my at 0x7fae9a4883a0, file "<string>", line 2>
>>> print(my.__globals__)
{'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': <class '_frozen_importlib.BuiltinImporter'>, '__spec__': None, '__annotations__': {}, '__builtins__': <module 'builtins' (built-in)>, 'z': 3, 'my': <function my at 0x7fee736c9d30>}
>>> my.n = 4
>>> print(my.__dict__)
{'n': 4}
>>> print(my.__closure__)
None
>>> print(my.__annotations__)
{'a': <class 'int'>, 'b': <class 'int'>, 'return': <class 'int'>}
>>> print(my.__kwdefaults__)
{'b': 3}

>>> f = my(1)
>>> print(f.__closure__)
(<cell at 0x7fee738214c0: int object at 0x955e40>, <cell at 0x7fee7372cd90: int object at 0x955e80>)
```

- Instance methods - объект метода экземпляра объединяет класс, инстанс класса и вызываемый объект (обычно пользовательскую функцию).

Специальные атрибуты только для чтения: `__self__` это объект экземпляра класса, `__func__` это объект функции; `__doc__` документация метода (то же, что и `__func__.__doc__`); `__name__` это имя метода (то же, что и `__func__.__name__`); `__module__`- это имя модуля, в котором был определен метод, или None если он недоступен.

Пример

```python
>>> class My():
    
...     def my(self):
...         """This is the doc"""
...         pass

>>> m = My()

>>> print(m.my.__self__)
<__main__.My object at 0x7fb701ba44c0>
>>> print(m.my.__doc__)
This is the doc
>>> print(m.my.__func__)
<function My.my at 0x7fb701a4cdc0>
>>> print(m.my.__name__)
my
>>> print(m.my.__module__)
__main__
```

Объект создается при получении атрибута класса. если этот атрибут является функцией или методом класса.

Когда объект метода экземпляра создается путем извлечения функции из экземпляра класса `__self__` является экземпляром, а объект метода называется связанным (bound method). `__func__` - это исходный объект функции.

Когда объект метода экземпляра создается путем извлечения объекта метода класса из класса, его `__self__` атрибутом является сам класс, а его `__func__` атрибутом является объект функции, лежащий в основе метода класса.

Заметка будет дополняться...

[Data model](https://docs.python.org/3/reference/datamodel.html#implementing-descriptors)

Смотри еще:

- [[python-standart-library]]
- [[python-descriptors]]

[//begin]: # "Autogenerated link references for markdown compatibility"
[python-standart-library]: python-standart-library "Стандартная библиотека python - список заметок"
[python-descriptors]: ../notes/python-descriptors "Python descriptors"
[//end]: # "Autogenerated link references"