<!DOCTYPE html>
<html lang="ru-RU">

<html>

  <head>

    <meta charset="UTF-8">
    <!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Heroku основная статья | My knowlege base</title>
<meta name="generator" content="Jekyll v3.8.7" />
<meta property="og:title" content="Heroku основная статья" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Основаная статья и список заметок о хостинге heroku" />
<meta property="og:description" content="Основаная статья и список заметок о хостинге heroku" />
<link rel="canonical" href="https://konstantinklepikov.github.io/myknowlegebase/lists/heroku.html" />
<meta property="og:url" content="https://konstantinklepikov.github.io/myknowlegebase/lists/heroku.html" />
<meta property="og:site_name" content="My knowlege base" />
<script type="application/ld+json">
{"@type":"WebPage","url":"https://konstantinklepikov.github.io/myknowlegebase/lists/heroku.html","headline":"Heroku основная статья","description":"Основаная статья и список заметок о хостинге heroku","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="preload" href="https://fonts.googleapis.com/css?family=Open+Sans:400,700&display=swap" as="style"
        type="text/css" crossorigin>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    
    
    <link rel="stylesheet" href="https://konstantinklepikov.github.io/myknowlegebase/assets/css/style.css">

    <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->


  <!-- Yandex.Metrika counter -->
  <script type="text/javascript" >
    (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
    m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

    ym(53548570, "init", {
        clickmap:true,
        trackLinks:true,
        accurateTrackBounce:true
    });
  </script>
  <noscript><div><img src="https://mc.yandex.ru/watch/53548570" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
    <!-- /Yandex.Metrika counter -->
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-139620627-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-139620627-1');
  </script>


<!-- Favicon -->
<link rel="icon" href="/myknowlegebase/assets/img/favicon.ico" type="image/x-icon">
<link rel="shortcut icon" href="/myknowlegebase/assets/img/favicon.ico" type="image/x-icon">

<!-- Math support -->
<!-- Mathjax Support -->
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>

<!-- end custom head snippets -->

</head>

  <body>

    <header class="page-header" role="banner">
    <h1 class="project-name">My knowlege base</h1>
    <h2 class="project-tagline">Мои заметки о программировании, data science и алгоритмах, собранные в процессе обучения</h2>
    <p class="project-tagline">Блог автора: <a class="project-tagline header-links" href="https://konstantinklepikov.github.io/">My deep learning</a></p>
</header>

    <main id="content" class="main-content" role="main">

      <p><a href="/myknowlegebase/">На главную</a></p>

<h1 id="heroku-основная-статья">Heroku основная статья</h1>

<p><a href="https://devcenter.heroku.com/categories/heroku-architecture">Heroku dev center</a></p>

<h2 id="dynos">Dynos</h2>

<p><a href="https://devcenter.heroku.com/articles/dynos">Dynos and the Dyno Manager</a></p>

<ul>
  <li>Web: Web dynos are dynos of the “web” process type that is defined in your Procfile. Only web dynos receive HTTP traffic from the routers.</li>
  <li>Worker: Worker dynos can be of any process type declared in your Procfile, other than “web”. Worker dynos are typically used for background jobs, queueing systems, and timed jobs. You can have multiple kinds of worker dynos in your application. For example, one for urgent jobs and another for long-running jobs. For more information, see Worker Dynos, Background Jobs and Queueing.</li>
  <li>One-off: One-off dynos are temporary dynos that can run detached, or with their input/output attached to your local terminal. They’re loaded with your latest release. They can be used to handle administrative tasks, such as database migrations and console sessions. They can also be used to run occasional background work, as with Heroku Scheduler. For more information, see One-Off Dynos.</li>
</ul>

<p>To scale horizontally (scale out), add more dynos. For example, adding more web dynos allows you to handle more concurrent HTTP requests, and therefore higher volumes of traffic. To scale vertically (scale up), use bigger dynos. The maximum amount of RAM available to your application depends on the dyno type you use. Both horizontal and vertical scale are features of the professional dynos, and are not available to free or hobby dynos.</p>

<p><a href="https://devcenter.heroku.com/categories/networking-dns">Networking &amp; DNS</a></p>

<h2 id="heroku-cli"><a href="https://devcenter.heroku.com/categories/command-line">Heroku CLI</a></h2>

<p>[<a href="../notes/heroku-cli" title="heroku-cli">heroku-cli</a>]</p>

<h2 id="deployment"><a href="https://devcenter.heroku.com/categories/deployment">Deployment</a></h2>

<p>[<a href="../notes/heroku-release-phase" title="Heroku-release-phase">heroku-release-phase</a>]</p>

<p>Можно деплоиться с гитхаба, можно <a href="https://devcenter.heroku.com/categories/deploying-with-docker">деплоиться через контейнеры</a> [<a href="../notes/docker" title="Docker">docker</a>].</p>

<p>Деплой с докером можно реализовать двумя путями:</p>

<h3 id="деплой-пресобранных-контейнеров-на-heroku"><a href="https://devcenter.heroku.com/articles/container-registry-and-runtime">деплой пресобранных контейнеров на heroku</a></h3>

<p>Make sure you have a working Docker installation (eg. docker ps) and that you’re logged in to Heroku (<code class="language-plaintext highlighter-rouge">heroku login</code>).</p>

<p>Log in to Container Registry:</p>

<p><code class="language-plaintext highlighter-rouge">heroku container:login</code></p>

<p>Get sample code by cloning an Alpine-based python example:</p>

<p><code class="language-plaintext highlighter-rouge">git clone https://github.com/heroku/alpinehelloworld.git</code></p>

<p>Navigate to the app’s directory and create a Heroku app:</p>

<p><code class="language-plaintext highlighter-rouge">heroku create</code></p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Creating salty-fortress-4191... <span class="k">done</span>, stack is heroku-18
https://salty-fortress-4191.herokuapp.com/ | https://git.heroku.com/salty-fortress-4191.git
</code></pre></div></div>

<p>Build the image and push to Container Registry:</p>

<p><code class="language-plaintext highlighter-rouge">heroku container:push web</code></p>

<p>Then release the image to your app:</p>

<p><code class="language-plaintext highlighter-rouge">heroku container:release web</code></p>

<p>Now open the app in your browser:</p>

<p><code class="language-plaintext highlighter-rouge">heroku open</code></p>

<p><a href="https://devcenter.heroku.com/articles/container-registry-and-runtime#logging-in-to-the-registry">более подробно обо всех нюансах</a></p>

<h3 id="создание-контейнеров-с-herokuyml"><a href="https://devcenter.heroku.com/articles/build-docker-images-heroku-yml">создание контейнеров с heroku.yml</a></h3>

<p>The <code class="language-plaintext highlighter-rouge">heroku.yml</code> file is a manifest you can use to define your Heroku app. It allows you to:</p>

<ul>
  <li>Build <code class="language-plaintext highlighter-rouge">Docker</code> images on Heroku</li>
  <li>Specify add-ons and config vars to create during app provisioning</li>
  <li>Take advantage of Review Apps when deploying Docker-based applications</li>
</ul>

<p>Create a <code class="language-plaintext highlighter-rouge">heroku.ym</code>l file in your application’s root directory. The following example <code class="language-plaintext highlighter-rouge">heroku.yml</code> specifies the Docker image to build for the app’s web process:</p>

<div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">build</span><span class="pi">:</span>
  <span class="na">docker</span><span class="pi">:</span>
    <span class="na">web</span><span class="pi">:</span> <span class="s">Dockerfile</span>
<span class="na">run</span><span class="pi">:</span>
  <span class="na">web</span><span class="pi">:</span> <span class="s">bundle exec puma -C config/puma.rb</span>
</code></pre></div></div>

<p>In this example, both <code class="language-plaintext highlighter-rouge">heroku.yml</code> and <code class="language-plaintext highlighter-rouge">Dockerfile</code> are in the same directory. If the <code class="language-plaintext highlighter-rouge">Dockerfile</code> lives in a non-root directory, specify the relative path in the <code class="language-plaintext highlighter-rouge">build.docker.web</code> value, such as <code class="language-plaintext highlighter-rouge">app/Dockerfile</code>.</p>

<p>If you don’t include a run section, Heroku uses the CMD specified in the Dockerfile.</p>

<p>Commit the file to your repo:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git add heroku.yml
git commit <span class="nt">-m</span> <span class="s2">"Add heroku.yml"</span>
</code></pre></div></div>

<p>Set the stack of your app to container:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>heroku stack:set container
</code></pre></div></div>

<p>Push your app to Heroku:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git push heroku master
</code></pre></div></div>

<p>Your application will be built, and Heroku will use the run command provided in heroku.yml instead of your Procfile.</p>

<p><a href="https://devcenter.heroku.com/articles/build-docker-images-heroku-yml#heroku-yml-overview">Подроюнее про содержание heroku.yml</a></p>

<h2 id="local-development-with-docker-compose"><a href="https://devcenter.heroku.com/articles/local-development-with-docker-compose">Local Development with Docker Compose</a></h2>

<p>Example [<a href="../notes/docker-compose" title="Docker-compose">docker-compose</a>]. That python application depends on [<a href="../notes/postgres" title="postgres">postgres</a>] and [<a href="../notes/redis" title="Redis">redis</a>], which you do not push to Heroku. Instead, use Heroku add-ons in production.</p>

<p><strong>Use Heroku add-ons in production:</strong></p>

<ul>
  <li>For local development: use official Docker images, such as Postgres and Redis.</li>
  <li>For staging and production: use Heroku add-ons, such as <a href="https://devcenter.heroku.com/articles/heroku-postgresql">heroku-postgres</a> and Heroku Redis.</li>
</ul>

<p>Using official Docker images locally and Heroku add-ons in production provides you with the best of both worlds:</p>

<ul>
  <li>Parity: You get parity by using the same services on your local machine as you do in production</li>
  <li>Reduced ops burden: By using add-ons, Heroku – or the add-on provider – takes the ops burden of replication, availability, and backup.</li>
</ul>

<p>When using Docker Compose for local development, there are a few tips and tricks we think can help make you more successful.</p>

<p><strong>Create an .env file to avoid checking credentials into source code control</strong>
By using Docker and Docker Compose, you can check your local development environment setup into source code control. To handle sensitive credentials, create a <code class="language-plaintext highlighter-rouge">.env</code> environment file with your credentials and reference it within your Compose YAML. Your .env should be added to your <code class="language-plaintext highlighter-rouge">.gitignore</code> and <code class="language-plaintext highlighter-rouge">.dockerignore</code> files so it is not checked into source code control or included in your [<a href="../notes/docker" title="Docker">docker</a>] image, respectively.</p>

<div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">services</span><span class="pi">:</span>
  <span class="na">web</span><span class="pi">:</span>
    <span class="na">env_file</span><span class="pi">:</span> <span class="s">.env</span>
</code></pre></div></div>

<p><strong>Mount your code as a volume to avoid image rebuilds</strong>
Any time you make a change to your code, you need to rebuild your Docker image (which is a manual step and can be time consuming). To solve this issue, <strong>mount your code as a volume</strong>. Now rebuilds are no longer necessary when code is changed.</p>

<div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">services</span><span class="pi">:</span>
  <span class="na">web</span><span class="pi">:</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./webapp:/opt/webapp</span>
</code></pre></div></div>

<p><strong>Use hostnames to connect to containers</strong>
By default Compose sets up a single network for your app. When you name a service in your Compose YAML, it creates a hostname that you can then use to connect to the service.</p>

<p>Our services in Compose YAML:</p>

<div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">services</span><span class="pi">:</span>
  <span class="na">web</span><span class="pi">:</span>
  <span class="na">redis</span><span class="pi">:</span>
  <span class="na">db</span><span class="pi">:</span>
</code></pre></div></div>

<p>Our connection strings:</p>

<div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">postgres://db:5432</span>
<span class="s">redis://redis:6379</span>
</code></pre></div></div>

<p><strong>Running Compose in background mode</strong>
When you execute docker-compose up your project is running in the foreground, displaying the output of your services. You can shut down the services gracefully using <code class="language-plaintext highlighter-rouge">ctrl+c</code>.</p>

<p>One lesser known option is to use <code class="language-plaintext highlighter-rouge">docker-compose up -d</code> to start your containers in the background (i.e., detached mode); you can tear down the Compose setup using <code class="language-plaintext highlighter-rouge">docker-compose down</code>. You check the logs of services running in background mode using <code class="language-plaintext highlighter-rouge">docker-compose logs</code>.</p>

<p><strong>Multi-dockerfile project structure</strong>
When you have multiple services, we suggest creating a subdirectory for each Docker image in your project, with the <code class="language-plaintext highlighter-rouge">Dockerfile</code> stored in each respective directory:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">/web/Dockerfile
/redis/Dockerfile
/db/Dockerfile
/worker/Dockerfile
</span></code></pre></div></div>

<p>We don’t recommend storing all <code class="language-plaintext highlighter-rouge">Dockerfiles</code> in the project home directory, since it makes distinguishing between services harder.</p>

<p><strong>Run your containers as a non-root user</strong>
It’s a good security practice to run your containers as a non-root user; but more importantly, containers you push to Heroku will run without root access. By testing your containers locally as a non-root user, you can ensure they will work in your Heroku production environment. Learn more in the container registry documentation.</p>

<h2 id="deployment-integrations"><a href="https://devcenter.heroku.com/categories/deployment-integrations">Deployment Integrations</a></h2>

<p><a href="https://devcenter.heroku.com/articles/github-integration">Деплой через гитхаб</a>
Другие интеграции смотри по ссылке</p>

<h2 id="continuous-delivery"><a href="https://devcenter.heroku.com/categories/continuous-delivery">Continuous Delivery</a></h2>

<ul>
  <li>[<a href="../notes/heroku-piplines" title="Heroku-piplines">heroku-piplines</a>] make it easy to maintain separate staging and production environments for your app.</li>
  <li>[<a href="../notes/heroku-review" title="Heroku-review">heroku-review</a>] apps let you try out a GitHub pull request’s changes in an isolated and disposable environment.</li>
  <li>[[Heroku-CI]] automatically runs your app’s test suite on new GitHub pull requests, or when code is merged into your repo’s master branch.</li>
  <li>[<a href="../notes/heroku-release-phase" title="Heroku-release-phase">heroku-release-phase</a>] phase lets you run tasks (such as database migrations) before a new release is deployed.</li>
</ul>

<p><a href="https://devcenter.heroku.com/articles/pipelines">Создание пайплайнов</a>
<a href="https://devcenter.heroku.com/articles/github-integration-review-apps">review app</a>
<a href="https://devcenter.heroku.com/articles/heroku-ci">heroku-cl</a></p>

<p>Heroku CI automatically runs your app’s test suite with every push to your app’s GitHub repository, enabling you to easily review test results before merging or deploying changes to your codebase. Tests execute in a disposable environment that closely resembles your staging and production environments, which helps to ensure that results are accurate and obtained safely.</p>

<p><a href="https://devcenter.heroku.com/articles/release-phase">Release Phase</a></p>

<p>Больше опций и вопросов интеграции в статье <a href="https://devcenter.heroku.com/categories/continuous-delivery">Continuous Delivery</a></p>

<h2 id="language-support"><a href="https://devcenter.heroku.com/categories/language-support">Language Support</a></h2>

<h2 id="databases--data-management"><a href="https://devcenter.heroku.com/categories/data-management">Databases &amp; Data Management</a></h2>

<h2 id="monitoring--metrics"><a href="https://devcenter.heroku.com/articles/metrics">Monitoring &amp; Metrics</a></h2>

<h2 id="app-performance"><a href="https://devcenter.heroku.com/categories/app-performance">App Performance</a></h2>

<p>Аддоны, бестпрактикс, секюритити и прочее смотри в  оглавлении документации</p>

<ul>
  <li>[<a href="../notes/heroku-variables-config" title="Heroku-variables-config">heroku-variables-config</a>]</li>
  <li>[<a href="../notes/requirements" title="Requirements.txt">requirements</a>]</li>
</ul>



<div class="additional-pad">
  <p><a href="/myknowlegebase/">На главную</a></p>
</div>


      <footer class="site-footer">
    <span class="site-footer-owner"><a href="/myknowlegebase/">My knowlege base</a> поддерживается <a href="https://github.com/KonstantinKlepikov">KonstantinKlepikov</a></span>
    <span class="site-footer-credits">Блог автора: <a href="https://konstantinklepikov.github.io/">My deep learning</a></span>
</footer>

    </main>

  </body>

</html>

<script type="text/javascript">
  // Hack: Replace page-link with "Page Title"
  document.querySelectorAll(".markdown-body a[title]").forEach((a) => {
    a.innerText = a.title;
  });
  // Hack: Remove .md extension from wikilinks to get the html in jekyll
  document.querySelectorAll("a").forEach(l => {
    if (l.href.endsWith('.md')) {
      l.href = l.href.substring(0, l.href.length-3)
    }
  })
</script>