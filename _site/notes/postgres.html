<!DOCTYPE html>
<html lang="ru_RU">

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Postgres | My knowledge base</title>
<meta name="generator" content="Jekyll v3.8.7" />
<meta property="og:title" content="Postgres" />
<meta property="og:locale" content="ru_RU" />
<meta name="description" content="База данных postgres" />
<meta property="og:description" content="База данных postgres" />
<link rel="canonical" href="https://konstantinklepikov.github.io/myknowlegebase/notes/postgres.html" />
<meta property="og:url" content="https://konstantinklepikov.github.io/myknowlegebase/notes/postgres.html" />
<meta property="og:site_name" content="My knowledge base" />
<script type="application/ld+json">
{"@type":"WebPage","url":"https://konstantinklepikov.github.io/myknowlegebase/notes/postgres.html","headline":"Postgres","description":"База данных postgres","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <meta name="keywords" content="">
    <link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

    
    
    <link rel="stylesheet" href="https://konstantinklepikov.github.io/myknowlegebase/assets/style.css">
    <script async defer src="https://buttons.github.io/buttons.js"></script>

    <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->


      <!-- Yandex.Metrika counter -->
  <script type="text/javascript" >
    (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
    m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

    ym(53548570, "init", {
        clickmap:true,
        trackLinks:true,
        accurateTrackBounce:true
    });
  </script>
  <noscript><div><img src="https://mc.yandex.ru/watch/53548570" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
    <!-- /Yandex.Metrika counter -->
      <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-139620627-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-139620627-1');
  </script>


<!-- Favicon -->
<link rel="icon" href="https://konstantinklepikov.github.io/myknowlegebase/assets/img/favicon.ico" type="image/x-icon">
<link rel="shortcut icon" href="https://konstantinklepikov.github.io/myknowlegebase/assets/img/favicon.ico" type="image/x-icon">

<!-- Math support -->
<!-- Mathjax Support -->
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>

<!-- tags collection-->

    







<!-- end custom head snippets -->

</head>

  <body>

    <header class="border-bottom-thick px-2 clearfix">
    <div class="left sm-width-full py-1 mt-1 mt-lg-0">
      <a class="align-middle link-primary text-accent" href="https://konstantinklepikov.github.io/">
        My deep learning
      </a>
    </div>
    <div class="right sm-width-full">
      <ul class="list-reset mt-lg-1 mb-2 mb-lg-1">
        <li class="inline-block">
          <a class="align-middle link-primary mr-2 mr-lg-0 ml-lg-2" href="/myknowlegebase/">
            My knowledge base
          </a>
        </li>
      </ul>
    </div>
  </header>

    <main role="main">

      
<article class="container mx-auto px-2 mt2 mb4">
  <header>
    <h1 class="h1 col-9 sm-width-full py-4 mt-3 inline-block" itemprop="name headline">Postgres</h1>
  </header>
  <div class="col-4 sm-width-full border-top-thin">
    <p class="mb-3 h5">Теги:
      
        
        <a href="/myknowlegebase/tag/databases" title="databases" class="link-tags">databases&nbsp;</a>
      
      </p>
  </div>
  <div class="prose mb-4 py-4">
    <p>* Статья является сокращением “Postgresql знакомство” Лузанов, Лёвшин, Рогов.</p>

<p>“PostgreSQL обеспечивает полную поддержку свойств ACID и обеспечивает эффективную изоляцию транзакций. Для этого в PostgreSQL используется механизм многоверсионного управления одновременным доступом (MVCC), который позволяет обходиться без блокировок строк во всех случаях, кроме одновременного изменения одной и той же строки данных в нескольких процессах: читающие транзакции никогда не блокируют пишущих транзакций, а пишущие — читающих.</p>

<p>Это справедливо и для самого строгого уровня изоляции serializable, который, используя инновационную систему Serializable Snapshot Isolation, обеспечивает полное отсутствие аномалий сериализации и гарантирует, что при одновременном выполнении транзакций результат будет таким же, как и при последовательном выполнении.</p>

<p>PostgreSQL эффективно использует современную архитектуру многоядерных процессоров — производительность СУБД растет практически линейно с увеличением количе- ства ядер.</p>

<p>Есть возможность параллельного выполнения запросов: PostgreSQL умеет распараллеливать чтение данных и соединения (в том числе и для секционированных таблиц), выполнять в параллельном режиме ряд служебных команд (создание индексов, очистку). JIT-компиляция запросов по- вышает возможности использования аппаратных средств для ускорения операций.</p>

<p>В PostgreSQL реализованы различные способы индексирования. Помимо традиционных B-деревьев доступно множество других методов доступа:</p>

<ul>
  <li>Hash — индекс на основе хеширования. В отличие от B-деревьев, такие индексы работают только при проверке на равенство, но в ряде случаев могут оказаться компактнее и эффективнее.</li>
  <li>GiST — обобщенное сбалансированное дерево поиска, которое применяется для данных, не допускающих упорядочения. Примерами могут служить R-деревья для индексирования точек на плоскости с возможностью быстрого поиска ближайших соседей (k-NN search) и индексирование операции пересечения интервалов.</li>
  <li>SP-GiST — обобщенное несбалансированное дерево, основанное на разбиении области значений на непересекающиеся вложенные области. Примерами могут служить дерево квадрантов для пространственных данных и префиксное дерево для текстовых строк.</li>
  <li>GIN — обобщенный инвертированный индекс, который используется для сложных значений, состоящих из элементов. Основной областью применения является полнотекстовый поиск, где требуется находить документы, в которых встречается указанные в поисковом запросе слова. Другим примером использования является поиск значений в массивах данных</li>
  <li>RUM — дальнейшее развитие метода GIN для полнотекстового поиска. Этот индекс, доступный в виде расширения, позволяет ускорить фразовый поиск и сразу выдавать результаты упорядоченными по релевантности.</li>
  <li>BRIN — компактная структура, позволяющая найти компромисс между размером индекса и скоростью поиска. Такой индекс эффективен на больших кластеризованных таблицах.</li>
  <li>Bloom — индекс, основанный на фильтре Блума. Такой индекс, имея очень компактное представление, позволяет быстро отсечь заведомо ненужные строки, однако требует перепроверки оставшихся</li>
</ul>

<p>Многие типы индексов могут создаваться не только по одному, но и по нескольким столбцам таблицы. Независимо от типа можно строить индексы как по столбцам, так и по произвольным выражениям, а также создавать частичные индексы только для определенных строк. Покрывающие индексы позволяют ускорить запросы за счет того, что все необходимые данные извлекаются из самого индекса без обращения к таблице. В арсенале планировщика имеется сканирование по бито- вой карте, которое позволяет объединять сразу несколько индексов для ускорения доступа</p>

<p>Пользователи могут самостоятельно, не меняя базовый код системы, добавлять:</p>

<ul>
  <li>типы данных,</li>
  <li>функции и операторы для работы с новыми типами,</li>
  <li>индексные и табличные методы доступа,</li>
  <li>языки серверного программирования,</li>
  <li>подключения к внешним источникам данных (Foreign Data Wrappers),</li>
  <li>загружаемые расширения</li>
</ul>

<h2 id="подключение-с-помощью-psql">Подключение с помощью psql</h2>

<p><code class="language-plaintext highlighter-rouge">sudo -u postgres psql</code></p>

<p>Создание БД</p>

<div class="language-md highlighter-rouge"><div class="highlight"><pre class="highlight"><code>postgres=# CREATE DATABASE test;
CREATE DATABASE

postgres=# <span class="se">\c</span> test
You are now connected to database "test" as user "postgres".
test=#
</code></pre></div></div>

<p>Команды, начинающиеся с <code class="language-plaintext highlighter-rouge">\</code> - это специальные команды psql. Они не доступны в обычных SQL-запросах.</p>

<p>Создание таблицы</p>

<div class="language-md highlighter-rouge"><div class="highlight"><pre class="highlight"><code>test=# CREATE TABLE courses( test(#
c_no text PRIMARY KEY,
test(# title text,
test(# hours integer
test(# );
CREATE TABLE
</code></pre></div></div>

<p>В этой командемыопределили, что таблица с именем courses будет состоять из трех столбцов: c_no — текстовый номер курса, title — название курса, и hours — целое число лекционных часов. Кроме столбцов и типов данных мы можем определить ограничения целостности, которые будут автоматически проверяться — СУБД не допустит появление в базе некорректных данных. В нашем примере мы добавили ограничение PRIMARY KEY для столбца c_no, которое говорит о том, что значения в этом столбце должны быть уникальными, а неопределенные значения не допускаются. Такой столбец можно использовать для того, чтобы отличить одну строку в таблице от других. <a href="https://postgrespro.ru/doc/ddl-constraints">Полный список ограничений целостности</a></p>

<p>Добавляем даныне</p>

<div class="language-md highlighter-rouge"><div class="highlight"><pre class="highlight"><code>test=# INSERT INTO courses(c_no, title, hours)
VALUES  ('CS301', 'Базы данных', 30),
        ('CS305', 'Сети ЭВМ', 60);
INSERT 0 2
</code></pre></div></div>

<p><a href="https://postgrespro.ru/docs/postgrespro/14/sql-copy">Смотри загрузку данных из ф-ла</a></p>

<p>Для дальнейших примеров нам потребуется еще две таблицы: студенты и экзамены. Для каждого студента будем хранить его имя и год поступления; идентифицироваться он будет числовым номером студенческого билета.</p>

<div class="language-md highlighter-rouge"><div class="highlight"><pre class="highlight"><code>test=# CREATE TABLE students(
    s_id integer PRIMARY KEY,
    name text,
    start_year integer
);
CREATE TABLE

test=# INSERT INTO students(s_id, name, start_year)
VALUES  (1451, 'Анна', 2014),
        (1432, 'Виктор', 2014),
        (1556, 'Нина', 2015);
INSERT 0 3
</code></pre></div></div>

<p>Экзамен содержит оценку, полученную студентом по некоторой дисциплине. Таким образом, студенты и дисциплины связаны друг с другом отношением «многие ко многим»: один студент может сдавать экзамены по многим дисциплинам, а экзамен по одной дисциплине могут сдавать много студентов.</p>

<p>Запись в таблице экзаменов идентифицируется совокупностью номера студбилета и номера курса. Такое ограничение целостности, относящее сразу к нескольким столбцам, определяется с помощью фразы CONSTRAINT</p>

<div class="language-md highlighter-rouge"><div class="highlight"><pre class="highlight"><code>test=# CREATE TABLE exams(
    s_id integer REFERENCES students(s_id),
    c_no text REFERENCES courses(c_no),
    score integer,
    CONSTRAINT pk PRIMARY KEY(s_id, c_no)
);
CREATE TABLE
</code></pre></div></div>

<p>Кроме того, с помощью фразы REFERENCES мы определили два ограничения ссылочной целостности, называемые внешними ключами. Такие ограничения показывают, что значения в одной таблице ссылаются на строки в другой таблице.</p>

<p>Теперь при любых действиях СУБД будет проверять, что все идентификаторы s_id, указанные в таблице экзаменов, соответствуют реальным студентам (то есть записям в таблице студентов), а номера c_no — реальным курсам. Таким образом, будет исключена возможность оценить несуще- ствующего студента или поставить оценку по несуществующей дисциплине</p>

<h2 id="sql-запросы">SQL-запросы</h2>

<h3 id="простые">Простые</h3>

<p>Две колонки</p>

<div class="language-md highlighter-rouge"><div class="highlight"><pre class="highlight"><code>test=# SELECT title AS course_title, hours FROM courses;
course_title  | hours
--------------+-------
Базы данных   | 30
Сети ЭВМ      | 60
(2 rows)
</code></pre></div></div>

<p>Все что есть в таблице</p>

<div class="language-md highlighter-rouge"><div class="highlight"><pre class="highlight"><code>test=# SELECT <span class="err">*</span> FROM courses;
c_no   | title       | hours
-------+-------------+-------
CS301  | Базы данных | 30
CS305  | Сети ЭВМ    | 60
(2 rows)
</code></pre></div></div>

<p>Убираем дублирующие значения <a href="https://postgrespro.ru/docs/postgrespro/14/sql-select#SQL-DISTINCT">с помощью DISTINCT</a></p>

<div class="language-md highlighter-rouge"><div class="highlight"><pre class="highlight"><code>test=# SELECT DISTINCT start_year FROM students;
<span class="gh">start_year
------------
</span>2014
2015
(2 rows)
</code></pre></div></div>

<p>С условием для SELECT</p>

<div class="language-md highlighter-rouge"><div class="highlight"><pre class="highlight"><code>test=# SELECT <span class="err">*</span> FROM courses WHERE hours &gt; 45;
c_no   | title    | hours
-------+----------+-------
CS305  | Сети ЭВМ | 60
(1 row)
</code></pre></div></div>

<p>Условие должно иметь логический тип. Например, оно может содержать отношения =, &lt;&gt; (или !=), &gt;, &gt;=, &lt;, &lt;=; может объединять более простые условия с помощью логических операций AND, OR, NOT и круглых скобок — как в обычных языках программирования.</p>

<p>В результирующую таблицу попадают только те строки, для которых условие фильтрации истинно; если же значение ложно или не определено, строка отбрасывается:</p>

<ul>
  <li>результат сравнения чего-либо с неопределенным значением не определен;</li>
  <li>результат логических операций с неопределенным значением, как правило, не определен (исключения: true OR NULL = true, false AND NULL = false);</li>
  <li>для проверки определенности значения используются специальные отношения IS NULL (IS NOT NULL) и IS DISTINCT FROM (IS NOT DISTINCT FROM), а также бывает удобно воспользоваться функцией coalesce</li>
</ul>

<p><a href="https://postgrespro.ru/docs/postgrespro/14/functions-comparison">Подробнее</a></p>

<h3 id="соединения">Соединения</h3>

<p>Грамотно спроектированная реляционная база данных не содержит избыточных данных. Например, таблица экзаменов не должна содержать имя студента, потому что его можно найти в другой таблице по номеру студенческого билета.</p>

<p>Поэтому для получения всех необходимых значений в запросе часто приходится соединять данные из нескольких таблиц, перечисляя их имена во фразе FROM</p>

<div class="language-md highlighter-rouge"><div class="highlight"><pre class="highlight"><code>test=# SELECT <span class="err">*</span> FROM courses, exams;
</code></pre></div></div>

<p>То, что получилось, называется прямым или декартовым произведением таблиц — к каждой строке одной таблицы добавляется каждая строка другой.</p>

<p>Как правило, более полезный и содержательный результат можно получить, указав во фразе WHERE условие соединения</p>

<div class="language-md highlighter-rouge"><div class="highlight"><pre class="highlight"><code>test=# SELECT courses.title, exams.s_id, exams.score
FROM courses, exams
WHERE courses.c_no = exams.c_no;
title        | s_id | score
-------------+------+-------
Базы данных  | 1451 | 5
Базы данных  | 1556 | 5
Сети ЭВМ     | 1451 | 5
Сети ЭВМ     | 1432 | 4
(4 rows)
</code></pre></div></div>

<p>Запросы можно формулировать и в другом виде, указывая соединения с помощью ключевого слова JOIN</p>

<div class="language-md highlighter-rouge"><div class="highlight"><pre class="highlight"><code>test=# SELECT students.name, exams.score
FROM students
JOIN exams
    ON students.s_id = exams.s_id
    AND exams.c_no = 'CS305';
name    | score
--------+-------
Анна    | 5
Виктор   | 4
(2 rows)
</code></pre></div></div>

<p>С точки зрения СУБД обе формы эквивалентны, так что можно использовать тот способ, который представляется более наглядным.</p>

<p>Этот пример показывает, что в результат не включаются строки исходной таблицы, для которых не нашлось пары в другой таблице: хотя условие наложено на дисциплины, но при этом исключаются и студенты, которые не сдавали экзамен по данной дисциплине. Чтобы в выборку попали все студенты, надо использовать внешнее соединение:</p>

<div class="language-md highlighter-rouge"><div class="highlight"><pre class="highlight"><code>test=# SELECT students.name, exams.score
FROM students
LEFT JOIN exams
    ON students.s_id = exams.s_id
    AND exams.c_no = 'CS305';
name    | score
--------+-------
Анна    | 5
Виктор  | 4
Нина    |
(3 rows)
</code></pre></div></div>

<p>В этом примере в результат добавляются строки из левой таблицы (поэтому операция называется LEFT JOIN), для которых не нашлось пары в правой. При этом для столб- цов правой таблицы возвращаются неопределенные значения</p>

<p>Условия во фразе WHERE применяются к уже готовому результату соединений, поэтому, если вынести ограничение на дисциплины из условия соединения, Нина не попадет в выборку — ведь для нее exams.c_no не определен:</p>

<div class="language-md highlighter-rouge"><div class="highlight"><pre class="highlight"><code>test=# SELECT students.name, exams.score
FROM students
LEFT JOIN exams
    ON students.s_id = exams.s_id
WHERE exams.c_no = 'CS305';
name    | score
--------+-------
Анна    | 5
Виктор  | 4
(2 rows)
</code></pre></div></div>

<p>Соединения - это обычная и естественная для реляционных СУБД операция, и у PostgreSQL имеется целый арсенал эффективных механизмов для ее выполнения. Не соединяйте данные в приложении, доверьте эту работу серверу баз данных. <a href="https://postgrespro.ru/docs/postgrespro/14/sql-select#SQL-FROM">Подробнее</a></p>

<h2 id="позапросы">Позапросы</h2>

<p>Оператор SELECT формирует таблицу, которая может быть выведена в качестве результата, а может быть использована в другой конструкции языка SQL в любом месте, где по смыслу может находиться таблица. Такая вложенная команда SELECT, заключенная в круглые скобки, называется подзапросом</p>

<p>Если подзапрос возвращает ровно одну строку и ровно один столбец, его можно использовать как обычное скалярное выражение</p>

<div class="language-md highlighter-rouge"><div class="highlight"><pre class="highlight"><code>test=# SELECT name,
    (SELECT score
    FROM exams
    WHERE exams.s_id = students.s_id
    AND exams.c_no = 'CS305')
FROM students;
name    | score
--------+-------
Анна    | 5
Виктор  | 4
Нина    |
(3 rows)
</code></pre></div></div>

<p>Скалярные подзапросы можно также использовать в условиях фильтрации</p>

<div class="language-md highlighter-rouge"><div class="highlight"><pre class="highlight"><code>test=# SELECT <span class="err">*</span> FROM exams
WHERE   (SELECT start_year
        FROM students
        WHERE students.s_id = exams.s_id) &gt; 2014;
s_id  | c_no  | score
------+-------+-------
1556  | CS301 |
5 (1 row)
</code></pre></div></div>

<p>В SQL можно формулировать условия и на подзапросы, возвращающие произвольное количество строк. Для этого существует несколько конструкций, одна из которых — отношение IN — проверяет, содержится ли значение в таблице, возвращаемой подзапросом. В примере ниже выводятся даныне студентов, у которых есть какие-либо оценки.</p>

<div class="language-md highlighter-rouge"><div class="highlight"><pre class="highlight"><code>test=# SELECT name, start_year
FROM students
WHERE s_id IN (SELECT s_id FROM exams WHERE c_no = 'CS305');
name    | start_year
--------+------------
Анна    | 2014
Виктор  | 2014
(2 rows)
</code></pre></div></div>

<p>Отношение NOT IN возвращает противоположный результат. Еще одна возможность — использовать предикат EXISTS, проверяющий, что подзапрос возвратил хотя бы одну строку.</p>

<div class="language-md highlighter-rouge"><div class="highlight"><pre class="highlight"><code>test=# SELECT name, start_year
FROM students
WHERE NOT EXISTS (SELECT s_id FROM exams WHERE exams.s_id = students.s_id AND score = 5);
name    | start_year
--------+------------
Виктор  | 2014
(1 row)
</code></pre></div></div>

<p><a href="https://postgrespro.ru/docs/postgrespro/14/functions-subquery">Подробнее</a></p>

<p>после подзапроса можно указать про- извольное имя, которое называется псевдонимом (alias). Псевдонимы можно использовать и для обычных таблиц. Здесь s — псевдоним таблицы, а ce — псевдоним подзапроса.</p>

<div class="language-md highlighter-rouge"><div class="highlight"><pre class="highlight"><code>test=# SELECT s.name, ce.score
FROM students s
    JOIN    (SELECT exams.<span class="err">*</span>
            FROM courses, exams
            WHERE courses.c_no = exams.c_no
            AND courses.title = 'Базы данных') ce
    ON s.s_id = ce.s_id;
</code></pre></div></div>

<h3 id="сортировка">Сортировка</h3>

<p>Данные в таблицах не упорядочены, но часто бывает важно получить строки результата в строго определенном порядке. Для этого используется предло- жение ORDER BY со списком выражений, по которым надо выполнить сортировку. После каждого выражения (ключа сортировки) можно указать направление: ASC — по воз- растанию (этот порядок используется по умолчанию) или DESC — по убыванию. Операцию сортировки имеет смысл выполнять в конце запроса непосредственно перед получением результата; в подзапросах она обычно бессмысленна.</p>

<div class="language-md highlighter-rouge"><div class="highlight"><pre class="highlight"><code>test=# SELECT <span class="err">*</span> FROM exams ORDER BY score, s_id, c_no DESC;
s_id  | c_no  | score
------+-------+-------
1432  | CS305 | 4
1451  | CS305 | 5
1451  | CS301 | 5
1556  | CS301 | 5
(4 rows)
Здесь
</code></pre></div></div>

<p><a href="https://postgrespro.ru/docs/postgrespro/14/sql-select#SQL-ORDERBY">Подробнее</a></p>

<h3 id="группировка">Группировка</h3>

<p>При группировке в одной строке результата размещается значение, вычисленное на основании данных нескольких строк исходных таблиц. Вместе с группировкой используют агрегатные функции. Например, общее количество проведенных экзаменов, количество сдававших их студентов и средний балл:</p>

<div class="language-md highlighter-rouge"><div class="highlight"><pre class="highlight"><code>test=# SELECT count(<span class="err">*</span>), count(DISTINCT s_id), avg(score)
FROM exams;
count  | count | avg
-------+-------+--------------------
4      | 3     | 4.7500000000000000
(1 row)
</code></pre></div></div>

<p>В разбивке по номерам курсов с помощью предложения GROUP BY, в котором указываются ключи группировки:</p>

<div class="language-md highlighter-rouge"><div class="highlight"><pre class="highlight"><code>test=# SELECT c_no, count(<span class="err">*</span>), count(DISTINCT s_id), avg(score)
FROM exams
GROUP BY c_no;
c_no   | count | count | avg
-------+-------+-------+--------------------
CS301  | 2     | 2     | 5.0000000000000000
CS305  | 2     | 2     | 4.5000000000000000
(2 rows)
</code></pre></div></div>

<p><a href="https://postgrespro.ru/docs/postgrespro/14/functions-aggregate">Подробнее об агрегатных функциях</a></p>

<p>В запросах, использующих группировку, может возник- нуть необходимость отфильтровать строки на основании результатов агрегирования. Такие условия можно задать в предложении HAVING. Отличие от WHERE состоит в том, что условия WHERE применяются до группировки (в них можно использовать столбцы исходных таблиц), а условия HAVING — после группировки (и в них можно также использовать столбцы таблицы-результата). <a href="https://postgrespro.ru/docs/postgrespro/14/sql-select#SQL-GROUPBY">Подробнее</a></p>

<h3 id="изменениеудаление-данных">Изменение/удаление данных</h3>

<p>Изменение данных в таблице выполняет <a href="https://postgrespro.ru/docs/postgrespro/14/sql-update">оператор UPDATE</a>, в котором указываются новые значения полей для строк, определяемых предложением WHERE (таким же, как в операторе SELECT). <a href="https://postgrespro.ru/docs/postgrespro/14/sql-delete">Оператор DELETE</a> удаляет из указанной таблицы строки, определяемые все тем же предложением WHERE</p>

<div class="language-md highlighter-rouge"><div class="highlight"><pre class="highlight"><code>test=# UPDATE courses
SET hours = hours <span class="err">*</span> 2
WHERE c_no = 'CS301';
UPDATE 1
</code></pre></div></div>

<div class="language-md highlighter-rouge"><div class="highlight"><pre class="highlight"><code>test=# DELETE FROM exams
WHERE score &lt; 5;
DELETE 1
</code></pre></div></div>

<h3 id="транзакции">Транзакции</h3>

<p>Когда две операции надо совершить одновременно, потому что ни одна из них не имеет смысла без другой или данные одной приведут к несогласованному состоянию без данных второй. Такие операции, составляющие логически неделимую единицу работы, называются транзакцией.</p>

<div class="language-md highlighter-rouge"><div class="highlight"><pre class="highlight"><code>test=# BEGIN;
BEGIN

test=<span class="err">*</span># INSERT INTO groups(g_no, monitor)
SELECT 'A-101', s_id
FROM students WHERE name = 'Анна';
INSERT 0 1

test=<span class="err">*</span># COMMIT;
COMMIT
</code></pre></div></div>

<p>Звездочка в данном случае напоминает об открытой и незавершенной транзакции.</p>

<p>СУБД дает несколько очень важных гарантий:</p>

<ul>
  <li>Во-первых, любая транзакция либо выполняется целиком, либо не выполняется совсем. Если бы в одной из команд произошла ошибка, или мы самипрервали бы транзакцию командой ROLLBACK, то база данных осталась бы в том состоянии, в котором она была до команды BEGIN. Это свойство называется атомарностью.</li>
  <li>Во-вторых, когда фиксируются изменения транзакции, все ограничения целостности должны быть выполнены, иначе транзакция прерывается. В начале работы транзакции данные находятся в согласованном состоянии, и в конце своей работы транзакция оставляет их согласованными; это свойство так и называется — согласованность.</li>
  <li>В-третьих, другие пользователи никогда не увидят несогласованные данные, которые транзакция еще не зафиксировала. Это свойство называется изоляцией; за счет его соблюдения СУБД способна параллельно обслуживать много сеансов, не жертвуя корректностью данных. <strong>Особенностью PostgreSQL является очень эффективная реализация изоляции: несколько сеансов могут одновременно читать и изменять данные, не блокируя друг друга. Блокировка возникает только при одновременном изменении одной и той же строки двумя разными процессами</strong>.</li>
  <li>И в-четвертых, гарантируется долговечность: зафиксированные данные не пропадут даже в случае сбоя.</li>
</ul>

<p><a href="https://postgrespro.ru/docs/postgrespro/14/tutorial-transactions">Подробнее</a></p>

<h2 id="полезные-команды-psql">Полезные команды psql</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">\?</code> Справка по командам psql.</li>
  <li><code class="language-plaintext highlighter-rouge">\h</code> Справка по SQL: список доступных команд или синтаксис конкретной команды.</li>
  <li><code class="language-plaintext highlighter-rouge">\x</code> ереключает традиционный табличный вывод (столбцы и строки) на расширенный (каждый столбец на отдельной строке) и обратно. Удобно для просмотра нескольких «широких» строк.</li>
  <li><code class="language-plaintext highlighter-rouge">\l</code> Список баз данных. Список пользователей.</li>
  <li><code class="language-plaintext highlighter-rouge">\du</code> Список пользователей.</li>
  <li><code class="language-plaintext highlighter-rouge">\dt</code> Список таблиц. Список индексов.</li>
  <li><code class="language-plaintext highlighter-rouge">\di</code> Список индексов.</li>
  <li><code class="language-plaintext highlighter-rouge">\dv</code> Список представлений.</li>
  <li><code class="language-plaintext highlighter-rouge">\df</code> Список функций.</li>
  <li><code class="language-plaintext highlighter-rouge">\dn</code> Список схем.</li>
  <li><code class="language-plaintext highlighter-rouge">\dx</code> Список установленных расширений.</li>
  <li><code class="language-plaintext highlighter-rouge">\dp</code> Список привилегий.</li>
  <li><code class="language-plaintext highlighter-rouge">\d имя</code> Подробная информация по конкретному объ- екту базы данных.</li>
  <li><code class="language-plaintext highlighter-rouge">\d+ имя</code> И еще более подробная информация по кон- кретному объекту.</li>
  <li><code class="language-plaintext highlighter-rouge">\timing on</code> Показывать время выполнения операторов</li>
  <li><code class="language-plaintext highlighter-rouge">\q</code> Выход</li>
</ul>

<p>Смотри еще:</p>

<ul>
  <li><a href="https://hub.docker.com/_/postgres">docker image</a></li>
  <li>[<a href="../posts/2022-07-04-daily-note" title="Postgres Initialization scripts and unzip with init">2022-07-04-daily-note</a>] Postgres Initialization scripts</li>
  <li><a href="https://postgrespro.ru/docs/postgrespro/14/sql-commands">команды SQL, поддержвивемые в postgres pro</a></li>
</ul>


  </div>
</article>


    </main>

    <footer role="banner">
<div class="border-top-thin clearfix mt-2 mt-lg-4">
    <div class="container mx-auto px-2">
      <p class="col-8 sm-width-full left py-2 mb-0"><a href="/myknowlegebase/">My knowledge base</a> проект поддерживается <a class="text-accent" href="https://github.com/KonstantinKlepikov">KonstantinKlepikov</a></p>
      <ul class="list-reset right clearfix sm-width-full py-2 mb-2 mb-lg-0">
        <li class="inline-block mr-1">
          <a href="https://twitter.com/share" class="twitter-share-button" data-hashtags="My knowledge base">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
        </li>
      </ul>
    </div>
  </div>
</footer>

  </body>

</html>

<script type="text/javascript">
  // Hack: Replace page-link with "Page Title"
  document.querySelectorAll(".markdown-body a[title]").forEach((a) => {
    a.innerText = a.title;
  });
  // Hack: Remove .md extension from wikilinks to get the html in jekyll
  document.querySelectorAll("a").forEach(l => {
    if (l.href.endsWith('.md')) {
      l.href = l.href.substring(0, l.href.length-3)
    }
  })
</script>