<!DOCTYPE html>
<html lang="ru_RU">

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Begin Jekyll SEO tag v2.6.1 -->
<title>GDScript | My knowledge base</title>
<meta name="generator" content="Jekyll v3.8.7" />
<meta property="og:title" content="GDScript" />
<meta property="og:locale" content="ru_RU" />
<meta name="description" content="GDScript скриптовый язык игрового редакторо GodotEngine" />
<meta property="og:description" content="GDScript скриптовый язык игрового редакторо GodotEngine" />
<link rel="canonical" href="https://konstantinklepikov.github.io/myknowlegebase/notes/gdscript.html" />
<meta property="og:url" content="https://konstantinklepikov.github.io/myknowlegebase/notes/gdscript.html" />
<meta property="og:site_name" content="My knowledge base" />
<script type="application/ld+json">
{"description":"GDScript скриптовый язык игрового редакторо GodotEngine","@type":"WebPage","url":"https://konstantinklepikov.github.io/myknowlegebase/notes/gdscript.html","headline":"GDScript","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <meta name="keywords" content="">
    <link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

    
    
    <link rel="stylesheet" href="https://konstantinklepikov.github.io/myknowlegebase/assets/style.css">
    <script async defer src="https://buttons.github.io/buttons.js"></script>

    <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->


      <!-- Yandex.Metrika counter -->
  <script type="text/javascript" >
    (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
    m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

    ym(53548570, "init", {
        clickmap:true,
        trackLinks:true,
        accurateTrackBounce:true
    });
  </script>
  <noscript><div><img src="https://mc.yandex.ru/watch/53548570" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
    <!-- /Yandex.Metrika counter -->
      <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-139620627-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-139620627-1');
  </script>


<!-- Favicon -->
<link rel="icon" href="https://konstantinklepikov.github.io/myknowlegebase/assets/img/favicon.ico" type="image/x-icon">
<link rel="shortcut icon" href="https://konstantinklepikov.github.io/myknowlegebase/assets/img/favicon.ico" type="image/x-icon">

<!-- Math support -->
<!-- Mathjax Support -->
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>

<!-- tags collection-->

    







<!-- end custom head snippets -->

</head>

  <body>

    <header class="border-bottom-thick px-2 clearfix">
    <div class="left sm-width-full py-1 mt-1 mt-lg-0">
      <a class="align-middle link-primary text-accent" href="https://konstantinklepikov.github.io/">
        My deep learning
      </a>
    </div>
    <div class="right sm-width-full">
      <ul class="list-reset mt-lg-1 mb-2 mb-lg-1">
        <li class="inline-block">
          <a class="align-middle link-primary mr-2 mr-lg-0 ml-lg-2" href="/myknowlegebase/">
            My knowledge base
          </a>
        </li>
      </ul>
    </div>
  </header>

    <main role="main">

      
<article class="container mx-auto px-2 mt2 mb4">
  <header>
    <h1 class="h1 col-9 sm-width-full py-4 mt-3 inline-block" itemprop="name headline">GDScript</h1>
  </header>
  <div class="col-4 sm-width-full border-top-thin">
    <p class="mb-3 h5">Теги:
      
        
        <a href="/myknowlegebase/tag/gamedev" title="gamedev" class="link-tags">gamedev&nbsp;</a>
      
    </p>
  </div>
  <div class="prose mb-4 py-4">
    <p><a href="https://gdscript.com/">GDScripts</a> разработан как пользовательский язык сценариев для использования с игровым движком Godot.</p>

<p>GDScript — это объектно-ориентированный и императивный язык программирования, созданный для Godot. Его особенности включают в себя:</p>

<ul>
  <li>Простой синтаксис, который приводит к коротким файлам.</li>
  <li>Молниеносная скорость компиляции и загрузки.</li>
  <li>Тесная интеграция редактора с завершением кода для узлов, сигналов и дополнительной информации из сцены, к которой он прикреплен.</li>
  <li>Встроенные типы векторов и преобразований, что делает его эффективным для интенсивного использования линейной алгебры, необходимой для игр.</li>
  <li>Поддерживает несколько потоков так же эффективно, как языки со статической типизацией.</li>
  <li>Нет сборки мусора, так как эта функция со временем мешает при создании игр. Движок подсчитывает ссылки и управляет памятью для вас в большинстве случаев по умолчанию, но вы также можете управлять памятью, если вам это нужно.</li>
  <li>Постепеннвый вывод. Переменные имеют динамические типы по умолчанию, но вы также можете использовать подсказки типов для строгой проверки типов.</li>
</ul>

<p>GDScript выглядит как Python, когда вы структурируете свои блоки кода с помощью отступов, но на практике он работает иначе. Он вдохновлен несколькими языками, включая Squirrel, Lua и Python.</p>

<h2 id="особенности">Особенности</h2>

<p>Каждый файл GDScript неявно является классом. Технически скрипт - не класс. Вместо этого он сообщает движку о последовательности инициализации, необходимой для запуска build-in классов. Внешние классы обращаются к собственной БД Godot, котоаря обеспечивает доступ к информации классов в рантайм. Эта дб хранит свойства, методы, константы и сигналы. Прикрепление скриптов к объектам расширяет эти осущности.</p>

<p>Ключевое слово <code class="language-plaintext highlighter-rouge">extends</code> определяет класс, которому этот сценарий наследует или расширяет. К примеру для Sprite2D.gd запись в начале файла <code class="language-plaintext highlighter-rouge">extend Sprite2D</code> означает, что наш скрипт получит доступ ко всем свойствам и функциям ноды <code class="language-plaintext highlighter-rouge">Sprite2D</code>, включая классы, которые он расширяет, такие как <code class="language-plaintext highlighter-rouge">Node2D</code>, <code class="language-plaintext highlighter-rouge">CanvasItem</code> и <code class="language-plaintext highlighter-rouge">Node</code>.</p>

<p>В GDScript, если вы опустите строку с <code class="language-plaintext highlighter-rouge">extends</code>, ваш класс будет неявно расширять <code class="language-plaintext highlighter-rouge">RefCounted</code>, который Godot использует для управления памятью вашего приложения.</p>

<p>К унаследованным свойствам относятся те, которые вы можете увидеть в доке Inspector, например, <code class="language-plaintext highlighter-rouge">texture</code> ноды.</p>

<p>По умолчанию Inspector отображает свойства ноды в «Заглавном регистре» с заглавными буквами, разделенными пробелом. В коде GDScript эти свойства находятся в «snake_case», то есть в нижнем регистре со словами, разделенными символом подчеркивания</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">func</span> <span class="n">_init</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Hello, world!"</span><span class="p">)</span>
</code></pre></div></div>

<p>Ключевое слово func определяет новую функцию с именем <code class="language-plaintext highlighter-rouge">_init</code>. Это специальное имя для конструктора нашего класса. Механизм обращается <code class="language-plaintext highlighter-rouge">_init()</code> к каждому объекту или ноде при их создании в памяти, если вы определяете эту функцию.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">var</span> <span class="n">speed</span> <span class="o">=</span> <span class="mi">400</span>
<span class="n">var</span> <span class="n">angular_speed</span> <span class="o">=</span> <span class="n">PI</span>
</code></pre></div></div>

<p>Входящие переменные располагаются в верхней части скрипта после любых строк <code class="language-plaintext highlighter-rouge">extends</code>, но перед функциями. К примеру, каждый экземпляр ноды с прикрепленным к нему скриптом будет иметь собственную копию свойств speed и angular_speed. Ноды в Godot по умолчанию работают в радианах, но у вас есть встроенные функции и свойства, если вы предпочитаете вместо этого вычислять углы в градусах.</p>

<p>Игры работают, отображая множество изображений в секунду, каждое из которых называется кадром, и они делают это в цикле. Мы измеряем скорость, с которой игра создает изображения, в кадрах в секунду (FPS). Большинство игр нацелены на 60 кадров в секунду, хотя вы можете найти такие цифры, как 30 кадров в секунду на более медленных мобильных устройствах или от 90 до 240 для игр виртуальной реальности.</p>

<p>Разработчики движка и игры делают все возможное, чтобы обновлять игровой мир и рендерить изображения с постоянным интервалом времени, но всегда есть небольшие различия во времени рендеринга кадров. Встроенный параметр <code class="language-plaintext highlighter-rouge">delta</code> делает наше движение независимым от частоты кадров.</p>

<p>В примере ниже мы используем собственную функцию класса <code class="language-plaintext highlighter-rouge">Node</code> для вращения объекта, к которому прикреплен скрипт.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">func</span> <span class="n">_process</span><span class="p">(</span><span class="n">delta</span><span class="p">):</span>
    <span class="n">rotation</span> <span class="o">+=</span> <span class="n">angular_speed</span> <span class="o">*</span> <span class="n">delta</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">_process()</code>, как <code class="language-plaintext highlighter-rouge">_init()</code>, начинается с подчеркивания. По соглашению, функции Godot, то есть встроенные функции, которые вы можете переопределить для связи с движком, начинаются с символа подчеркивания.</p>

<p><code class="language-plaintext highlighter-rouge">rotation</code> - это свойство класса. Оно работает с радианами и управляет вращением. <code class="language-plaintext highlighter-rouge">rotation += angular_speed * delta</code>. В редакторе кода вы можете щелкнуть, удерживая клавишу <code class="language-plaintext highlighter-rouge">Ctrl</code>, любое встроенное свойство или функцию, например <code class="language-plaintext highlighter-rouge">position</code>, <code class="language-plaintext highlighter-rouge">rotation</code>, или <code class="language-plaintext highlighter-rouge">_process</code> и открыть соответствующую документацию на новой вкладке.</p>

<p>Переменные внутри функции определяют локальные переменные в области действия функции.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">func</span> <span class="n">_process</span><span class="p">(</span><span class="n">delta</span><span class="p">):</span>
    <span class="n">rotation</span> <span class="o">+=</span> <span class="n">angular_speed</span> <span class="o">*</span> <span class="n">delta</span>

    <span class="n">var</span> <span class="n">velocity</span> <span class="o">=</span> <span class="n">Vector2</span><span class="p">.</span><span class="n">UP</span><span class="p">.</span><span class="n">rotated</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">*</span> <span class="n">speed</span>

    <span class="n">position</span> <span class="o">+=</span> <span class="n">velocity</span> <span class="o">*</span> <span class="n">delta</span>
</code></pre></div></div>

<p>Мы определяем локальную переменную с именем <code class="language-plaintext highlighter-rouge">velocity</code>, двумерный вектор, представляющий как направление, так и скорость. Чтобы заставить узел двигаться вперед, мы начинаем с константы класса <code class="language-plaintext highlighter-rouge">Vector2</code> <code class="language-plaintext highlighter-rouge">Vector2.UP</code>, вектора, направленного вверх, и поворачиваем его, вызывая <code class="language-plaintext highlighter-rouge">rotated()</code>. Это выражение <code class="language-plaintext highlighter-rouge">Vector2.UP.rotated(rotation)</code> представляет собой вектор, указывающий вперед относительно нашего оринетира. Умноженное на наше <code class="language-plaintext highlighter-rouge">speed</code>, он дает нам скорость, которую мы можем использовать для перемещения ноды. <code class="language-plaintext highlighter-rouge">position</code> так же имеет встроенный тип <code class="language-plaintext highlighter-rouge">Vector2</code></p>

<h2 id="пользовательский-ввод">Пользовательский ввод</h2>

<p>У вас есть два основных инструмента для обработки ввода игрока в Godot:</p>

<ul>
  <li>Встроенные колбеки ввода, в основном <code class="language-plaintext highlighter-rouge">_unhandled_input()</code>. Например <code class="language-plaintext highlighter-rouge">_process()</code>, это встроенная функция, которую Godot вызывает каждый раз, когда игрок нажимает кнопку. Это инструмент, который вы захотите использовать для реагирования на события, которые не происходят в каждом кадре, например, нажатие <code class="language-plaintext highlighter-rouge">Space</code> для прыжка. <a href="https://docs.godotengine.org/en/stable/tutorials/inputs/inputevent.html#doc-inputevent">Подробнее</a></li>
  <li>Синглтон <code class="language-plaintext highlighter-rouge">Input</code>. Синглтон — это глобально доступный объект. Godot предоставляет доступ к нескольким сценариям. Это правильный инструмент для проверки ввода в каждом кадре.</li>
</ul>

<p>Подробный пример с <code class="language-plaintext highlighter-rouge">Input</code> <a href="https://docs.godotengine.org/en/stable/getting_started/step_by_step/scripting_player_input.html">смотри тут</a>.</p>

<h2 id="сцены"><a href="https://docs.godotengine.org/en/stable/tutorials/best_practices/scene_organization.html">Сцены</a></h2>

<p>Сцены в Godot - это любой реюзабельынй обхект игры, от персонажа до обстановки уровня.</p>

<p>Когда пользователи Godot начинают создавать свои собственные сцены, они часто сталкиваются со следующей проблемой: они создают свою первую сцену и наполняют ее контентом только для того, чтобы в конечном итоге сохранить ветви своей сцены в отдельные сцены, поскольку начинает накапливаться ощущение, что все это должно быть разделено. Однако затем они замечают, что жесткие ссылки, на которые они могли полагаться раньше, больше невозможны. Повторное использование сцены в нескольких местах создает проблемы, поскольку пути к узлам не находят своих целей, а сигналы, установленные в редакторе, разрываются.</p>

<p>Чтобы устранить эти проблемы, необходимо создать экземпляры подсцен. Нужно быть уверенным в том, что подсцена создастся независимо, не привязывась к тому ,как она в итоге будет использована.</p>

<p>Одна из самых важных вещей, которые следует учитывать в ООП, — это поддержка функциональных классов с единственной решаемой задачей со слабой связью с другими частями кодовой базы. Это сохраняет размер объектов небольшим (для удобства сопровождения) и улучшает возможность их повторного использования.</p>

<p>Эти лучшие практики ООП имеют несколько последствий для лучших практик в структуре сцены и использовании скриптов.</p>

<p>Если это вообще возможно, следует проектировать сцены без зависимостей. То есть надо создавать сцены, которые держат в себе все необходимое.</p>

<p>Если сцена должна взаимодействовать с внешним контекстом, рекомендуется использовать Dependency Injection. Этот метод предполагает, что высокоуровневый API предоставляет зависимости от низкоуровневого API. Зачем это делать? Потому что классы, которые полагаются на свой внешний контекст, могут непреднамеренно вызывать ошибки и неожиданное поведение.</p>

<p>Чтобы добиться этого необходимо предоставить данные, а затем полагаться на родительский контекст для их инициализации:</p>

<ul>
  <li>Подключиться к сигналу. Чрезвычайно безопасный способо, но его следует использовать только для того, чтобы «отреагировать» на поведение, а не запускать его. Обратите внимание, что имена сигналов обычно представляют собой глаголы в прошедшем времени, такие как «введенный», «навык_активированный» или «предмет_собранный».</li>
  <li>Вызов метода. Используется для начала поведения.</li>
  <li>Инициализация свойства Callable. Безопаснее, чем метод, поскольку владение методом не требуется. Используется для начала поведения.</li>
  <li>Инициализировать ссылку на узел или другой объект.</li>
  <li>Инициализировать NodePath.</li>
</ul>

<p>Эти опции скрывают точки доступа от дочернего узла. Это, в свою очередь, удерживает Child в слабой связи с окружением. Его можно повторно использовать в другом контексте без каких-либо дополнительных изменений в его API.</p>

<p>Хотя приведенные выше примеры иллюстрируют отношения родитель-потомок, одни и те же принципы применимы ко всем объектным отношениям. Узлы, которые являются братьями и сестрами, должны знать только о своей иерархии, в то время как предок опосредует их связь и ссылки. Те же принципы применимы и к объектам, не являющимся узлами, которые поддерживают зависимости от других объектов. Какой бы объект фактически ни владел объектами, он должен управлять отношениями между ними.</p>

<p>Следует отдавать предпочтение хранению данных в сцене, хотя размещение зависимости от внешнего контекста, даже слабо связанного, по-прежнему означает, что узел будет ожидать, что что-то, что ожидается в его среде будет истинным. Если этого не делать, сильные связи кода заставят разработчиков использовать документацию для отслеживания объектных отношений в микроскопическом масштабе; это также известно как ад развития. Написание кода, который опирается на внешнюю документацию для безопасного использования по умолчанию подвержено ошибкам.</p>

<p>В godot куфлизован графический интерфейс информирования пользователя о внешних зависимостях. Есть ли внешние зависимости? Были ли удовлетворены эти зависимости? Другим программистам, и особенно дизайнерам и писателям, потребуются четкие инструкции в сообщениях, говорящие им, что делать, чтобы настроить это.</p>

<p>Сцены работают лучше всего, когда они работают в одиночку. Если вы не можете работать в одиночку, то лучше всего работать с другими анонимно (с минимальными жесткими зависимостями, т. е. со слабой связью). Неизбежно может потребоваться внести изменения в класс, и если эти изменения заставят его непредвиденным образом взаимодействовать с другими сценами, тогда все начнет ломаться. Весь смысл всей этой косвенности состоит в том, чтобы избежать ситуации, когда изменение одного класса приводит к неблагоприятному воздействию на другие классы, зависящие от него.</p>

<h2 id="выбор-структуры-дерева-узлов">Выбор структуры дерева узлов</h2>

<p>Итак, разработчик может знать, что он хочет делать, какие системы он хочет иметь, но где их все разместить? Можно построить деревья узлов бесчисленным количеством способов, но есть общие рекомендации.</p>

<p>В игре всегда должна быть своего рода «точка входа»; место где все начинается. Это место также служит обзором всех остальных данных и логики программы. Для традиционных приложений это будет «основная» функция. В данном случае это будет основной узел <code class="language-plaintext highlighter-rouge">Node "Main" (main.gd)</code>.</p>

<p>Затем у каждой игры есть свой настоящий внутриигровой «Мир» (2D или 3D). Это может быть дочерний элемент Main. Кроме того, для их игры потребуется основной графический интерфейс, который управляет различными меню и виджетами, необходимыми для проекта.</p>

<blockquote>
  <p>Node “Main” (main.gd)
-&gt; Node2D/Node3D “World” (game_world.gd)
-&gt; Control “GUI” (gui.gd)</p>
</blockquote>

<p>При изменении уровней можно поменять местами потомков узла «World». Изменение сцен вручную дает пользователям полный контроль над тем, как меняется их игровой мир.</p>

<p>Следующим шагом будет рассмотрение того, какие системы геймплея требуются для вашего проекта. Если требуется система, которая:</p>

<ul>
  <li>отслеживает все свои данные внутри</li>
  <li>должна быть глобально доступна</li>
  <li>должна существовать изолированно</li>
</ul>

<p>тогда нужно <a href="https://docs.godotengine.org/en/stable/tutorials/scripting/singletons_autoload.html#doc-singletons-autoload">создать узел</a> “singleton” автозагрузки.</p>

<p>Для небольших игр более простой альтернативой с меньшим контролем было бы наличие синглтона «Game», который просто вызывает метод <code class="language-plaintext highlighter-rouge">SceneTree.change_scene_to_file()</code> для замены содержимого основной сцены. Эта структура более или менее сохраняет World в качестве основного узла.</p>

<p>Любой графический интерфейс также должен быть одноэлементным; быть преходящей частью World; или быть добавленным вручную как прямой дочерний элемент корня. В противном случае узлы GUI также удаляли бы себя во время перехода между сценами.</p>

<p>Если у вас есть системы, которые изменяют данные других систем, их следует определить как собственные сценарии или сцены, а не автозагрузки. Дополнительные сведения о причинах см. <a href="https://docs.godotengine.org/en/stable/tutorials/best_practices/autoloads_versus_internal_nodes.html#doc-autoloads-versus-internal-nodes">в документации по автозагрузкам и обычным узлам</a>.</p>

<p>Каждая подсистема в игре должна иметь свой собственный раздел в <code class="language-plaintext highlighter-rouge">SceneTree</code>. Отношения родитель-потомок следует использовать только в тех случаях, когда узлы фактически являются элементами своих родителей.</p>

<p>Ключом к организации сцены является рассмотрение <code class="language-plaintext highlighter-rouge">SceneTree</code> в реляционных, а не пространственных терминах. Зависят ли узлы от существования своего родителя? Если нет, то они могут существовать сами по себе где-то еще. Если они зависимы, то само собой разумеется, что они должны быть детьми этого родителя (и, вероятно, частью сцены этого родителя, если они еще не являются).</p>

<p>Означает ли это, что сами узлы являются компонентами? Нисколько. Деревья узлов Godot формируют отношение агрегации, а не отношения композиции. Но хотя у вас все еще есть возможность перемещать узлы, все же лучше, когда такие перемещения не нужны по умолчанию.</p>

<h2 id="когда-лучше-использовать-сцены-а-когда-скрипт"><a href="https://docs.godotengine.org/en/stable/tutorials/best_practices/scenes_versus_scripts.html">Когда лучше использовать сцены, а когда скрипт</a></h2>

<p>Скрипты определяют расширение класса движка с императивным кодом, сцены с декларативным кодом.</p>

<p>В результате возможности каждой системы различны. Сцены могут определять, как инициализируется расширенный класс, но не то, каково его поведение на самом деле. Сцены часто используются в сочетании со скриптом, где сцена объявляет состав узлов, а скрипт добавляет поведение с императивным кодом.</p>

<h3 id="анонимные-типы">Анонимные типы</h3>

<p>Можно полностью определить содержание сцены, используя только скрипт. Это, по сути, то, что делает редактор Godot, только в конструкторе C++ своих объектов.</p>

<p>Но выбор того, какой из них использовать, может быть дилеммой. Создание экземпляров скрипта идентично созданию классов в движке, тогда как обработка сцен требует изменения в API.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">const</span> <span class="n">MyNode</span> <span class="o">=</span> <span class="n">preload</span><span class="p">(</span><span class="s">"my_node.gd"</span><span class="p">)</span>
<span class="n">const</span> <span class="n">MyScene</span> <span class="o">=</span> <span class="n">preload</span><span class="p">(</span><span class="s">"my_scene.tscn"</span><span class="p">)</span>
<span class="n">var</span> <span class="n">node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">.</span><span class="n">new</span><span class="p">()</span>
<span class="n">var</span> <span class="n">my_node</span> <span class="o">=</span> <span class="n">MyNode</span><span class="p">.</span><span class="n">new</span><span class="p">()</span> <span class="c1"># Same method call
</span><span class="n">var</span> <span class="n">my_scene</span> <span class="o">=</span> <span class="n">MyScene</span><span class="p">.</span><span class="n">instantiate</span><span class="p">()</span> <span class="c1"># Different method call
</span><span class="n">var</span> <span class="n">my_inherited_scene</span> <span class="o">=</span> <span class="n">MyScene</span><span class="p">.</span><span class="n">instantiate</span><span class="p">(</span><span class="n">PackedScene</span><span class="p">.</span><span class="n">GEN_EDIT_STATE_MAIN</span><span class="p">)</span> <span class="c1"># Create scene inheriting from MyScene
</span></code></pre></div></div>

<p>Кроме того, скрипты будут работать немного медленнее, чем сцены, из-за различий в скорости кода движка и скрипта. Чем больше и сложнее узел, тем больше причин строить его как сцену.</p>

<h3 id="именованные-типы">Именованные типы</h3>

<p>Скрипты могут быть зарегистрированы как новый тип в самом редакторе. Это отобразит его как новый тип в диалоговом окне создания узла или ресурса с необязательным значком. Таким образом, возможности пользователя по использованию скрипта значительно упрощаются. Вместо того чтобы:</p>

<ul>
  <li>Знать базовый тип скрипта, который вы хотели бы использовать.</li>
  <li>Создать экземпляр этого базового типа.</li>
  <li>Добавить скрипт в узел.</li>
</ul>

<p>… с зарегистрированным скриптом можно создавать скрипты непосредственно из диалогового окна.</p>

<p>Существует две системы регистрации типов.</p>

<p>Пользовательские типы:</p>

<ul>
  <li>Только для редактора. Имена типов недоступны во время выполнения.</li>
  <li>Не поддерживает унаследованные пользовательские типы.</li>
  <li>Средство инициализации. Создает узел со скриптом. Больше ничего.</li>
  <li>Редактор не распознает тип скрипта или его связь с другими типами движков или скриптами.</li>
  <li>Позволяет пользователям определять значок.</li>
  <li>Работает для всех языков сценариев, поскольку имеет дело с ресурсами сценария абстрактно.</li>
</ul>

<p>Классы сценариев</p>

<ul>
  <li>Доступен редактор и среда выполнения.</li>
  <li>Отображает отношения наследования полностью.</li>
  <li>Создает узел с помощью сценария, но также может изменять типы или расширять тип из редактора.</li>
  <li>Редактор знает об отношениях наследования между скриптами, классами скриптов и классами движка C++.</li>
  <li>Позволяет пользователям определять значок.</li>
  <li>Разработчики движка должны добавить поддержку языков вручную (как раскрытие имени, так и доступность во время выполнения).</li>
  <li>Редактор сканирует папки проекта и регистрирует любые открытые имена для всех языков сценариев. Каждый язык сценариев должен реализовать собственную поддержку для предоставления этой информации.</li>
</ul>

<p>Обе методологии добавляют имена в диалоговое окно создания, но классы сценариев, в частности, также позволяют пользователям получать доступ к имени типа без загрузки ресурса сценария. Создание экземпляров и доступ к константам или статическим методам возможно из любого места.</p>

<p>Последний аспект, который следует учитывать при выборе сцен и скриптов, — это скорость выполнения.</p>

<p>По мере увеличения размера объектов размер скриптов, необходимый для их создания и инициализации, становится больше. Создание иерархий узлов демонстрирует это. Логика каждого узла может состоять из нескольких сотен строк кода.</p>

<p>Код скрипта, намного медленнее, чем код C++ на стороне движка. Каждая инструкция вызывает API-интерфейс сценариев, что приводит к множеству «поисков» на серверной части, чтобы найти логику для выполнения.</p>

<p>Сцены помогают избежать этой проблемы с производительностью. <code class="language-plaintext highlighter-rouge">PackedScene</code>, базовый тип, от которого наследуются сцены, определяет ресурсы, использующие сериализованные данные для создания объектов. Движок может обрабатывать сцены пакетами на серверной части и обеспечивает гораздо лучшую производительность, чем сценарии.</p>

<p>В итоге:</p>

<ul>
  <li>Если кто-то хочет создать базовый инструмент, который будет повторно использоваться в нескольких различных проектах и ​​который, вероятно, будут использовать люди всех уровней квалификации (включая тех, кто не называет себя «программистами»), то есть вероятность, что это скрипт, вероятно, с пользовательским именем/значком.</li>
  <li>Если кто-то хочет создать концепцию, характерную для его игры, то это всегда должна быть сцена. Сцены легче отслеживать/редактировать, и они обеспечивают большую безопасность, чем сценарии.</li>
</ul>

<p>Полезные ссылки:</p>

<ul>
  <li><a href="https://docs.godotengine.org/en/stable/classes/class_%40globalscope.html#">@GlobalScope</a></li>
  <li><a href="https://docs.godotengine.org/en/stable/tutorials/export/exporting_projects.html">Exporting projects</a></li>
  <li><a href="https://docs.godotengine.org/en/stable/classes/class_sprite2d.html">Sprite2D</a></li>
  <li><a href="https://docs.godotengine.org/en/stable/classes/class_shape2d.html#class-shape2d">Shape2D</a></li>
  <li><a href="https://docs.godotengine.org/en/stable/classes/class_collisionobject2d.html">CollisionObject2D</a></li>
  <li><a href="https://docs.godotengine.org/en/stable/tutorials/assets_pipeline/importing_images.html#importing-textures">Importing images</a></li>
  <li><a href="https://docs.godotengine.org/en/stable/tutorials/2d/using_tilemaps.html#doc-using-tilemaps">Using TileMaps</a></li>
  <li><a href="https://docs.godotengine.org/en/stable/tutorials/2d/using_tilesets.html#doc-using-tilesets">Using TileSets</a></li>
  <li><a href="https://docs.godotengine.org/en/stable/tutorials/scripting/nodes_and_scene_instances.html">Nodes and scene instances</a></li>
  <li><a href="https://docs.godotengine.org/en/stable/tutorials/math/random_number_generation.html">Random number generation</a></li>
  <li><a href="https://docs.godotengine.org/en/stable/tutorials/scripting/debug/overview_of_debugging_tools.html">Overview of debugging tools</a></li>
  <li><a href="https://ask.godotengine.org/84708/duplicate-a-node-with-sub-nodes-and-change-position">Duplicate a node with sub-nodes and change position</a></li>
  <li><a href="https://forum.godotengine.org/t/how-to-disable-enable-a-node/22387">How to disable/enable a node?</a></li>
  <li><a href="https://forum.godotengine.org/t/access-a-nodes-child-by-name-not-path-or-index/13106">access a node’s child by name</a></li>
  <li><a href="https://docs.godotengine.org/en/stable/tutorials/2d/custom_drawing_in_2d.html">Custom drawing in 2D</a></li>
  <li><a href="https://kidscancode.org/godot_recipes/3.x/kyn/path2d/index.html">Path2D &amp; PathFollow2D</a></li>
  <li><a href="https://kidscancode.org/godot_recipes/3.x/2d/line_collision/index.html">Line2D Collision</a></li>
  <li><a href="https://forum.godotengine.org/t/how-can-i-get-a-node-from-an-instanced-scene-by-name/18851">How can I get a node from an instanced scene by name</a></li>
  <li><a href="https://lasteamlab.com/documentation/game-design/godot/RPG/lessons/7-screen-scrolling.html">Basic Screen Scrolling</a></li>
  <li><a href="https://forum.godotengine.org/t/how-to-make-an-infinite-scrolling-background/24114">How to make an infinite scrolling background</a></li>
  <li><a href="https://forum.godotengine.org/t/is-there-a-way-to-check-for-recently-freed-object/12772">a way to check for (recently) freed object</a></li>
  <li><a href="https://forum.godotengine.org/t/ways-to-lock-a-rotation/693">Ways to lock a rotation</a></li>
</ul>

<p>Смотри еще:</p>

<ul>
  <li><a href="https://docs.godotengine.org/en/stable/tutorials/scripting/gdscript/gdscript_basics.html#doc-gdscript">Документация GDScript</a></li>
  <li><a href="https://docs.godotengine.org/en/stable/classes/index.html">все классы в документации</a> [<a href="gdscript-classes" title="GDScript classes">gdscript-classes</a>] - кратко</li>
  <li><a href="https://docs.godotengine.org/en/stable/tutorials/scripting/gdscript/gdscript_basics.html">GDScript reference</a></li>
  <li><a href="https://docs.godotengine.org/en/stable/classes/index.html">все классы в документации</a></li>
  <li><a href="https://gdscript.com/">gdscript.com</a> туториалы и решения</li>
  <li><a href="https://github.com/godotengine/godot-demo-projects">godot demo projects</a></li>
  <li><a href="https://docs.godotengine.org/en/stable/tutorials/best_practices/index.html">best practicies</a></li>
  <li><a href="https://kidscancode.org/godot_recipes/4.x/">Godot Recipes</a></li>
  <li>[<a href="godot" title="godot engine">godot</a>]</li>
  <li>[<a href="gdscript-classes" title="GDScript classes">gdscript-classes</a>]</li>
  <li>[<a href="../lists/c-plus-plus" title="Ресурсы по языку программирования С/С++">c-plus-plus</a>]</li>
  <li>[<a href="../lists/gamedev" title="Gamedev">gamedev</a>]</li>
</ul>


  </div>
</article>


    </main>

    <footer role="banner">
<div class="border-top-thin clearfix mt-2 mt-lg-4">
    <div class="container mx-auto px-2">
      <p class="col-8 sm-width-full left py-2 mb-0"><a href="/myknowlegebase/">My knowledge base</a> проект поддерживается <a class="text-accent" href="https://github.com/KonstantinKlepikov">KonstantinKlepikov</a></p>
      <ul class="list-reset right clearfix sm-width-full py-2 mb-2 mb-lg-0">
        <li class="inline-block mr-1">
          <a href="https://twitter.com/share" class="twitter-share-button" data-hashtags="My knowledge base">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
        </li>
      </ul>
    </div>
  </div>
</footer>

  </body>

</html>

<script type="text/javascript">
  // Hack: Replace page-link with "Page Title"
  document.querySelectorAll(".markdown-body a[title]").forEach((a) => {
    a.innerText = a.title;
  });
  // Hack: Remove .md extension from wikilinks to get the html in jekyll
  document.querySelectorAll("a").forEach(l => {
    if (l.href.endsWith('.md')) {
      l.href = l.href.substring(0, l.href.length-3)
    }
  })
</script>